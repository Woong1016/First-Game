

#include <iostream>

int main()
{
	// 과제 : 포인터 연산자 써보기

	// 사칙연산 함수를 , 포인터를 이용해서 만들어보기

	// 1. 모든 함수는 void로 만들어주세요 0

	// 2. 매개 변수를 포인터로 만들어주세요 0   

	// 3. 함수의 사칙연산 수행은 "매개변수 x = 매개변수 x + 매개변수  " 처럼 생겨야 합니다.

	// 4. 함수 실행 후에, main() 에서 함수 실행 결과가 유지되도록 해주세요

	// 5. 결과를 출력


	// 심심풀이 도전?


	// : 지난 빙고 풀이에서 빙고 판 준비하기 함수도 매개변수를 써서 
	//		코드 줄을 줄일 수 있을까여?







	// 포인터 사용에 앞서

	  // 먼저 "매개변수 사용의 문제" 프로젝트엣 확인한 것을 요약

	  // 1. 변수는 자료형, 이름 , 값(실제내용)으로 이루어진다
	  // 2. 변수는 이름표가 붙은 각각의 메모리 주소에서 관리된다
	  // 3. 적ㄱ절한 연산자를 사용하면 그 메모리 주소를 보거나 다룰 수도 있다.

	  // 이때 변수의 메모리 주소를 보거나 . 해당 주소에 있는 내용을 수정하기 위한
	  // 이를 접근이라고 한다. 문법과 연산자를 통칭해서 포인터라고 한다


	  // -----------------------------

	  // 포인터를 사용하는 방법
	  // 먼저 그냥 변수 (일반 자료)

	  // 먼저 그냥 변수(일반 자료)
	int  a = 10; // 자료 , 이름 , 값



	// 출력

	std::cout << "변수 a : " << a << std::endl;

	// 그다음 변수가 있는 멤ㅎ리 위치를 확인하는 방법
	// 이를 참조라고 한다.

	// 변수 a의 메모리 위치(이를 주소라고 한다.)
	std::cout << "변수 a의 주소 : " << &a << std::endl;// a 앞에 & 붙이기

	// & : 참조 연산자
	// 변수 이름 앞에 붙이면, 해당 변수의 메모리 주소를 보여준다

	// 메모리 주소는 실행할 떄마다 바뀔 수도 있다. (os 내 최적화 때문)

	// &를 사용해서 나오는 결과 : 보통 8자리 혹은 16 자리의 16 진수
	// 32 비트 혹은 64비트 os 대응 메모리 총 범위에 따른 것


	//=======================================


	// 그리고 &를 스면 나오는 이 메모리 주소도
	// 따지고 보면 출력의 대상이 될 수 있다. (해보니까 됨)

	// 이것도 엄연히 컴퓨터가 인지할 수 있는 일종의 데이터다.
	//= 변수의 내용이 될 수 있다


	// 따라서 내용 있는 자료에 이름과 자료형을 붙여서 변수로 만들 수 있듯이

	// 변수의 메모리 주소 ... 라는 자료에도, 마찬가지로 이름과 자료형을 붙이면
	// 또 다른 변수로 만들 수 있다.


	// 이것을 "포인터 변수: 라고 한다
	// (가끔 이 포인터 변수를 줄여서 그냥 포인터라고 하기도 한다.)


	// ------------------------------------------



	// 포인터 변수 만드는 방법

	int* aPtr; // 포인터 변수 
				// * 연산자는 여기서는 곱하기가 아니다.

	//*: 포인터 연산자, 혹은 참조 연산자 (참조 연산자라고 할 경우, 위의 & 연산자와 한세트 취급)

	// 의미는 int 를 위해 컴퓨터가 지정해준 변수의 메모리 주소를 
	// 값으로 사용하는 포인터 변수로서의 자료형 이라는 뜻

	// 마찬가지로 포인터 적용된 변수 자료형들

	float* fPtr; // 소수의 포인터 변수 (소수 변수의 메모리 주소 할당가능)
	char* cPtr; // 글자의 포인터 변수
	bool* bPtr; // 논리 변수의 포인터 변수
	// 자료형으로 쓸 수 있는 타입의 거의 ㄷ다수는 포인터화가 가능하다
	// 자료형 뒤에 * 만 붙이면 끝

	// 그리고 이렇게 만든 포인터 변수에는 원래 내용으로 지정됐던 변수의
	// 메모리 주소를 값으로 할당할 수 있다.


	// 다시 말해 int*에는 int의 메모리 주소를 할당 가능

	// 예시 : 위에서 만든 aPtr 사용

	//aPtr = 100; // 숫자를 바로 넣으면 오류
	//aPtr = ff00faf; // 메모리 주소 같아 보이는 뭔가를 넣어도 오류


	aPtr = &a; // 아까 만들어둔 숫자 a의 메모리 주소를 aPtr 의 값으로 할당은 가능

	//그리고 이게 포인터 변수의 90% : 꼭 숙지

	// 변수가 있고 포인터 변수가 있고 
	// 포인터 변수의 값은 변수의 메모리 주소


	// 다른 예시로 요약


	int n = 1000; // int 변수

	int* nPtr = &n; // int 변수의 주소를 사용하는 포인터 변수

	// 다른 자료형도 가능(위에 만들어둔 포인터 변수 활용)

	float f = 300.0f;

	bool b = true;

	char c = 'A';

	fPtr = &f;// 소수 변수 f의 주소
	bPtr = &b;// 논리 변수 b의 주소
	cPtr = &c;// 문자 변수 c의 주소


	// 만든 포인터 변수 출력

	std::cout << "================" << std::endl;
	std::cout << "변수 a :" << a << std::endl;
	std::cout << "변수 f :" << f << std::endl;
	std::cout << "변수 b :" << b << std::endl;
	std::cout << "변수 c :" << c << std::endl;

	std::cout << "변수 a 위치 :" << &a << std::endl;
	std::cout << "변수 f 위치:" << &f << std::endl;
	std::cout << "변수 b 위치:" << &b << std::endl;
	std::cout << "변수 c 위치:" << &c << std::endl;

	std::cout << "포인터변수 a 위치 :" << aPtr << std::endl;
	std::cout << "포인터변수 f 위치:" << fPtr << std::endl;
	std::cout << "포인터변수 b 위치:" << bPtr << std::endl;
	std::cout << "포인터변수 c 위치:" << cPtr << std::endl;


	// 위 코드를 출력함으로써

	// 포인터 연산자를 써볼 수 있다.
	// 포인터 변수와 변수 주소의 관계를 알 수 있다.
	// 그리고 문자에 포인터 연산자를 넣었더니 이상한 일이 벌어짐
	//	이 부분은 우선 염두에 뒀다가 , 이후에 다시 확인해보자

	// 일단은 포인터를 이용해서 주소를 볼 수 있다는 것까지 확인한 것에 의의

	//============================================

	// 포인터 변수를 사용하면 메모리 주소를 알 수 있는데...

	// 그러면 그렇게 안 메모리 주소에 있는 (뭐가 됐든) 데이터는
	// 어떻게 하면 접근할 수 있을까?

	// 이 떄 사용하는 문법이 "역참조"

	// 변수의 => 메모리 주소 : 참조라면

	// 메모리 주소에 있는 -> 뭐가 됐든 자료로 쓸 데이터 : 역참조

	//역참조의 사용 방법 : 위에 만들어둔 포인터 변수들을 사용

	aPtr; // 이건 포인터 변수

	*aPtr; // 이것은 역참조

	// 자료형 뒤에 *연산자 : "이 변수는 포인터 변수입니다"
	

	// 포인터 변수 이름 앞에 -> *연산자 : "지금부터 이 주소의 값을 보겠습니다.?

	//같은 * 연산자인데 자료형 뒤냐 , 변수 이름 앞이냐에 따라 
	// 참조의 방향이 다르다: 주의! 그리고 숙지 할 것

	// 작성 예시 

	int u = 300; // 숫자 u
	int* uPtr = &u; // 포인터 변수 uPtr : u의 주소 사용

	std::cout << "u의 메모리 주소: " << uPtr << std::endl; // 주소출력
	std::cout << "uPtr 에 있던 값은  지금 1: " << *uPtr << std::endl; // 주소내용 출력

	*uPtr = 555; // 이것이 uPtr 메모리 주소에 있는 겂 = 다시말해 u의 실체

	//				그리고 지금 그 대상 (uPtr 위치에 있던 데이터)을 막 수정한 참


	std::cout << "uPtr 에 있던 값은  지금 2: " << *uPtr << std::endl; // 주소내용 출력

	//이어서 본래의 u도 출력

	std::cout << "원본 u는 지금 :  " << u << std::endl;



	// 따라서 여기서 우리는 두 사실을 알 수 있다.


	//1. *uPtr이라고 하면 메모리 주소의 실제 내용을 정말 바꿀 수 있다!
	//2. 변수는 곧 자료형 , 이름 (= 이름으로 된 메모리 주소), 실제 내용
	// 따라서 *uPtr 로 수정 가능한 데이터란 결국 u의 실체나 다를게 없다!
	// *uPtr 이 바로 u다.


	// 자료형 뒤에 *
	int* xPtr = &a; // 변수의 주소 = 포인터 변수

	// 선언이 끝난 포인터 변수 이름 앞에 *
	*uPtr = u; // 포인터 변수를 역 참조한 것 (메모리 주소에 있던 데이터) = 변수의 실체



	// 화이팅하세요

	int j = 500;

	std::cout << "j 의 값은 : "<<j << std::endl;
	std::cout << '\n';
	int* jPtr = &j;

	 *jPtr = 600;
	 std::cout << "j 의 값은 : "<<j << std::endl;
	

}
 