#pragma once
#include <iostream>
#include <string>

//음료수 클래스
// 음료수 : 사람이 마실 수 있는 식료의 통칭 (알콜 종류 포함)
class Baverage
{

public :
	// 생성자와 소멸자 (다른 내용없으므로 멤버 이니셜라이저로 여기서 작성 )
	Baverage(int cost, std::string name) : cost(cost), name(name){}
	~Baverage(){}

	int GetCost() { return cost; }
	std::string Getname() { return name; }

	//음료수를 마실 떄 실행할 함수
	void Drink() { std::cout << name << "을 마십니다." << std::endl; }
	

	// 음료수를 마실 때 우리가 할 수 있는 다른 행동 : 색깔 확인하기

	virtual void Color(){} // virtual : "이 함수는 내용이 없으며, 
										// 이 함수의 이름은 자식들과 공유합니다" 라는 의미의 정의 지시
										// 이렇게 이름을 만들어 자식들과 공유하는 , 내용 없는 함수
										// "가상 함수" 라고 한다.
										// 
	// 위처럼 가상 함수를 만들 수도 있지만 , 아직 이것만으로는 강제성이 없다
	// 여기에 강제성을 주기 위해서는 더 극단적인 작성을 해줄 수도 있다.

	//virtual void Color(); // 여기서 쓰인 virtual 은 의미가 있다 (이건 가상함수입니다.)
							// () 다음에 쓰인 = 0; : "이 함수는 진짜 아무것도 없어요
							// 얼마나 아무 것도 없습니다. 이 함수에는 아무것도 없어서
							// 이대로는 부모 클래스를 인스턴스로 생성도 못할 정도로

	//위와 같은 형태의 가상함수(virtual 자료형 함수명 () = 0) 작성을 하면:
	// -> 1. 이제 이 클래스는 단독으로 생성이 불가능해진다.
	// -> 2. 이 클래스를 앞으로 상속하는 클래스가 있다면 , *반드시* 이렇게 만든
	//		가상함수를 제대로 {}써서 작성을 해내야 한다. (안그러면 자식도 생성불가)

	// 순수 가상함수를 자식이 작성안하면 진짜 문제가 생기나?
	//virtual void TestVirtualFuntion() = 0; // 테스트용 가상함수
	//=> 이 함수가 있을 때 (자식 클래스는없음) 빌드와 실행이 되는지 확인
	// 
	//이렇게 극단적으로 내용을 없앤 - 심지어 내용이 없다는 사실을 딱 잘라 선언한,
	// 공백의 가상함술ㄹ ...

	//"순수 가상 함수" 라고 한다.

	//그리고, 이렇게 가상 함수와 순수 가상함수를 이용해서 

	// " 이 클래스를 상속하는 모든 클래스는 이 함수를 작성해야 한다!" 라고 규칙을 정하는 기법
	// 그리고 이 기법으로 만들어진 코드를 통칭해서

	//"인터페이스" (interface , 작성절차) 이라고 한다.

	// 또한 , 인터페이스 작성에 의해 만들어진 , 순수 가상 함수를 포함하며,
	// 단독으로 생성이 불가능한 클래스를 

	//"추상 클래스" (Avstract Class)라고한다. /

	// 더 좁은 의미로는 아예모든 내부의 함수가 순수 가상 함수라
	// 오직 자식 클래스에 대한 규칙만을 가지는 경우도 있다.

	//----------------------------------------------




	// 그럼 이 인터페이스를 어떻게 쓰는가? "main에서 확인
 

	// 굿
	// 졸지말고 코드 치십쇼. 손가락을 움직이세요 ㄴㄴㄴ 그래도 치십쇼.

protected :
	std::string name;
	int cost; // 가격


	//지.건 날려드릴게요
};

