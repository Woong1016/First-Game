#pragma once
#include "Baverage.h"

// 탄산음료 클래스



class Coke : public Baverage



	// 자식 클래스 생성자 만들기
	//가격과 이름을 받은 후 여기서 가격, 이름 : 부모 클래스에게 필요한 것
	// 멤버 이니셜라이저에서 부모의 생성자를 실행한다 부모를 같이 생성하는 것
{
public:

	Coke(int cost, std::string name) : Baverage(cost ,name){}
	~Coke();


	void Drink()
	{
		//자식 클래스에서 같은 행동, 다른 효과를 내야 할 때
		// 1. 자식 클래스에 부모 클래스와 같은 이름의 함수가 없으면:
		//-> 부모 클래스의 함수를 그대로 이용
		// => 편리, 간단하지만 자식클래스의 개성을 활용하지 못한다
		//
		//2.자식 클래스에 부모 클래스와 가은 이름의 함수가 있으면:
		//-> 이 경우, 부모 클래스의 함수를 자식 클래스의 함수가 갱신한다.

		// 이 기능을 "함수의 갱신(override ,오버라이드)"이라고 한다.

		//-> 자식 클래스에서 별도로 수행해야 하는 기능이 있는 경우
		// 이렇게 같은 이름을 만들어서 개성적인 코드를 따로 준다.

		//std::cout << name << " 을 마시자 목이 톡 쏘입니다. (앗따가!!)" << std::endl;

		// 하지만 자식클래스를 갱신하면 부모 클래스가 반대로 무시된다는게 단점
		// -> 이 경우 , 부모 크래스의 함수를 자식 클래스 안에서 한번 더 호출

		// 말하자면
		//1. 함수를 부르는 곳에서는 이 클래스의 함수 호출
		//2. 이 함수는 다시 부모 클래스의 함수 호출... 을 하는 것

		// 방법 -> 부모 클래스명:: 함수 이름
		Baverage::Drink(); // 부모로서 가진 기능을 먼저 써주고
		std::cout << name << " 을 마시자 목이 톡 쏘입니다. (앗따가!!)" << std::endl;
	}

	//가상 함수를 부모로부터 받아 작성하기
	virtual void Color() override
	{

		//virtual : 가상 함수 체제에서 작성했다는 의미 실제론 하는 일없는 정의 지시
		//override : 현재 작성된 이쪽 함수가 덮어쓰는 쪽이라고 가르쳐주는 의미
		std::cout << name << " 은 까맣습니다." << std::endl;
	
	
	
	
	}


};

