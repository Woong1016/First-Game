//과제
// 바카라 만들기
// 배열과제: 바카라(최소 규칙)

//* 이 과제를 랜덤 숫자의 사용이 필요합니다!(지난 과제 참조)

//1. 배열 하나 , 혹은 둘을 만들어주세요(하나면 되긴 한데 둘은 기분상) 클리어
//2. 만든 배열의 원소 값은 0부터 9까지로 할당해주세요(둘이어도 둘다) 클리어
//   *바카라에 나오는 j ,q,k 카드의 값은 0입니다. 클리어
//3. 바카라에는 두명의 플레이어가 있습니다: 하나는 "플레이어" 다른쪽은 "뱅커" 클리어 
//4. 플레어어와 뱅커는 게임을 시작하면 카드 두장을 뽑습니다. 
//	해당 카드의 숫자를 기록하기 위한 변수를 만들어주세요.
//(*중복 가능합니다.)
//5. 플레이어와 뱅커는 자기 카드 둘의 숫자를 더하고 , 십의 자리를 버립니다. 
// 예시 :9+8=17 인데 -> 10을 버리고 7이 된다.

//6. 플레이어는 여기서 자기(플레이어)와 상대(뱅커)중...
//	누구의 카드 합이 더 높은지 , 혹은 비겼는지 지정해야 합니다.
//	이과정을 입력으로 표현해주세요

//* 카드 값이 높게 나온쪽이 이기는게 아니고, 플레이어가 높은 쪽을 맞추면 이깁니다.

//7. 플레이어가 더 카드 합이 높은 쪽을 맞추면 승점 1점을 얻습니다.
// 틀리면 패점 1점을 얻습니다.

//8. 플레이어가 총 3번 이기거나, 3번 지면 게임은 끝납니다.

// 만들어야 할 변수가 여러가지 일 수 있습니다. 

// 옵션 : 승점, 패점 대신 판돈을 사용하는 게임으로 규칙
//2. 한쪽이 숫자가 너무 적으면 (5정도) 적은쪽에서 카드를 또 뽑을지 선택 시킬 수 있습니다.
//(스탠드)
//3. 비겼을 때, 승점이나 판돈 따기 등에 추가 배열을 줘볼 수도 있습니다.
// 4. 그 외에도 아시는 추가 규칙등이 있다면 넣자







#include <iostream>

int main()
{
	//변수를 만들고 다루다 보면 여러 개가 한 묶음을 이루기도 한다
	//특히 여러 변수가 서로 자료형도 같고 , 의미도 같은 경우...
	// 각각의 변수를 다른 것처럼 하나씩 만들면 귀찮다!
	
	//= 연관성 있는 비슷한 변수들을 한 번에 만들고 관리하고 싶다!!

	//c++에 이런 목적을 만족할 수 있는 기능이 있다.

	// "배열" (array)

	// 기본형태 : 

	int arr[10]; // 배열 선언하기
	int numbers[10] = {1,2,3,4,5,6,7,8,9,10}; // 배열을 할당하기
											// 혹은....
											// 선언 + 할당 = 초기화하기
											// = "배열은 초기화하기"
	// 이것이 배열을 만드는 방법
	// -> 같은 이름을 공유하는 10개의 변수를 한번에 만들어서 값넣기 	
	// <-array가 파란색글자 = 같은 이름을 쓰는 명령어가 또 있다.(쓰면 오류남)

	//도식화 하면

	// (자료형) 배열이름 [배열을 구성하는 구성요소 개수] = 
	// {1번째 구성요소 값 , 2번째 구성요소 값 , n번째 값까지..};

	// 그리고 여기서 배열을 구성하는 요소를 항목 , 혹은 원소로 지칭
	//그 원소의 개수를 크기라고 지칭한다

	// 다시 도식화하면

	// 자료형 배열이름[배열크기]={원소 1값, 원소2값, 원소3값, 원소n값};

	//==============================================================

	// 만들어진 배열을 출력하거나 계산하거나 수정하는 방법(다른말로 " 변수 접근")

	// 변수니까 배열도 자연스럽게 이름으로 불러내서 바꿀 수 있다?

	//arr = { 1,3,5,7,9,11,13,15,17,19 }; 오류발생?

	//답은 이렇게 하면 안된다!!

	// 배열은 만들때는 한번에 세트로 초기화를 해줄 수 있다.
	// 하지만 한번 만들어진 배열을 출력하거나, 계산하거나, 수정할 때는...

	// .... 각각의 구성요소를 따로따로 불러내서 연산해야한다.

	// 배열의 구성요소를 사용하는 기본 형태

	arr[0] = 100;// 배열의 구성요소 수정

	std::cout << arr[0] << std::endl; // 배열의 구성요소 출력

	// 위에 적은 배열 원소 수정의 의미 
	//arr: 배열의 이름 . 변수 세트를 사용한다는 의미.
	//[] : 배열을 만들 때 (= 자료형 + 변수 이름 뒤에 올때) 쓰면 배열의 크기를 뜻하지만
	//		배열의 이름을 불러낼 때 (자료형 없이 이름만 쓸 때) 쓰면 배열 속에 있는
	//		묶음 속의 n번째 원소를 불러내겠다는 뜻이 된다
	// [] 안에 들어간 숫자 0: 배열의 첫번째를 의미. 순번(index)이라고 지칭한다.
	//						배열은 0순번이 1번째이다. 즉 0부터 시작해서, 
	//						배열의 크기의 직전까지 순번이 돌아간다.
	//						(예: 10 크기의 배열은 0부터 9 까지 순번이 돈다)
	// 
	// 배열의 순번을 알아볼 수 있는 다른 예시
	//아래 코드의 [1]을 0부터 10 까지 (10: 배열크기)넣어보기
	// 순번에 10 을 넣으면 오류가 뜬다
	arr[1] = 200;
	std::cout << arr[3] << std::endl;
	// 배열의 사용을 도식화하면

	// 배열이름 [배열 순번]으로 연산

	// 예제 2. 배열의 원소들을 연산하는 (각 원소가 숫자임을 알 수 있는) 예시

	arr[2] = 300; // arr 배열 계속 사용
	//arr 배열과 numbers 배열을 서로 곱해서 출력
	std::cout << arr[2] * numbers[9] << std::endl;
	// 위 코드에서 numbers [] 숫자를 바꿔보자

	// 예제 3. 배열을 일괄 사용하는 방법 

	//		-> numbers 배열속의 모든 숫자를 다 출력해봅시다.

	
	std::cout << numbers[0] << std::endl;// 0순번
	std::cout << numbers[1] << std::endl;//1순번
	std::cout << numbers[2] << std::endl;//2순번
	std::cout << numbers[3] << std::endl;//3순번
	

	// 배열만큼 for 문이 잘어울리는 것도 없다.

	for (int i = 0; i < 10; i++)
	{
		//반복 조건이 i<10 이유는 배열이 10이라
		
		// 마침 조건이 i가 0부터 9까지 올라간다 = 배열 순번을 대신하기 매우좋다

		std::cout << numbers[i] << std::endl;
		// 반복할 때마다 i가 0부터 9까지 알아서 올라간다.
	}

	// 배열의 수저도 마찬가지 . 원소 순번으로 호출한 후 , 수정하고 , 연산하고, 출력한다.

	for (int i = 0; i < 10; i++)
	{
		//배열속 원소의 수정
		arr[i] = i * 100;// 구구단처럼 올라가는 i에 100을 곱하기
		std::cout << arr[i]+numbers[i] << std::endl;
	}
	// 절취선 
	std::cout << "=============================================="<<std::endl;

	// 이렇게 배열을 사용하면 같은 이름을 공유하는 같은 자료형의
	// 변수 여러개를 한번에 만들어서 반복문으로 일괄 관리해줄 수 있다

	//================================================================================


	// (확장)배열을 좀 더 크게 이해하는 방법

	// 1. 배열은 여러 변수를 하나로 묶은 것이다.
	// 2. 배열도 변수다 (int numbers[10]= {1,2,3,4,5,6,7,8,9,10};)

	// 1+2. 여러 배열을 하나로 묶은 것도 가능하지 않을까?
	// -> 가능하다!

	//예제

	int row1[3] ={ 1,2,3 };// 숫자 3개의 배열
	int	row2[3] = { 4,5,6 };// row1 과 같은 형식의 배열
	int	row3[3] = { 7,8,9 };// 같은크기 , 같은 자료형


	// 그리고 숫자 세개짜리 배열이라는 변수 세게를 다시 모아 묶은 것

	int table[3][3] = { 1,2,3,4,5,6,7,8,9 };// 마치 3x3= 9인것처럼

	// 위의 row1, 2,3과 같은 table[3][3]의 형태를 비교

	for (int i = 0; i < 3; i++)
	{
		std::cout << row1[i] << std::endl;//행 1이라는 배열 i번째
		std::cout << row2[i] << std::endl;//행 2이라는 배열 i번째
		std::cout << row3[i] << std::endl;//행 3이라는 배열 i번째
	}

	// table
	for (int i = 0; i < 3; i++)// 세번만 도는 반복문
	{
		//for 문 안에  다시 각 i번째마다 세번 따로 도는 반복문을 하나 더
		for (int j = 0; j < 3; j++)
		{
			//i가 한 번 실행될 때마다 j가 0부터 2까지 세번 실행된다
			// 합쳐서 3x3= 9 번 실행

			std::cout << table[i][j] << std::endl;
			//표 라고 하는 배열의 배열 출력
			// 1. table의 i번째 원소인 뒤쪽 [3]짜리 숫자 배열을
			//2. j번째로 돌아가면서 출력한다
			//3. 2의 과정을 i가 0부터 2가 될때까지 한다
			//예: i 반복문이 일단 0인상태로 시작함 그리고 그상태로 j 반복문으로 넘어가는데 
			// table 배열은 123 456 789로 나뉜 상태임 순번이 [0]123 [1]456 [2]789인 상태
			// i 반복문에서 처음 행인 [0]배열에서 j로 들어가서 3번 반복문이니까 123을 호출하는 거임

		}



	}


}

