

//  이 방법으로 무작위 숫자 배치 가능
//  무작위 빙고 판도 가능


#include <iostream>
#include <stdlib.h>
#include<Windows.h>

int main()
{
	srand(GetTickCount64());	// srand 도 사실 함수 (시드 생성)
								



	// 패 섞기

	// 목적 : 일괄 작성된 규칙적 변수를 랜덤으로 바꾸기 위함

	// 필요한 준비물

	// 1 실제로 섞을 변수

	int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };

	//2 랜덤 숫자를 뽑기 위한 기능과 시드 (위에 준비됨)

	// 원리

	// 배열은 순번으로 호출이 가능하므로,

	// 랜덤으로 순번 2곳을 찍어서 양 위치의 데이터를 서로 맞바꾸면 
	// 작은 불규칙이 생기게 된다



	// 그렇게 랜덤 2곳의 데이터를 맞바꾸는 일을 아주많이 하면...

	// 온 배열의 배치가 불규칙하게 바뀌게 된다

	//진행
	int a = 10;
	int b = 20;
	
	a = b;
	b = a;

	//흔한 맞바꾸기의 개념

	// 1. 반복문을 준비한다 (데이터 맞바꾸기를 아주 많이 한다)
	for (int i = 0; i < 1000; i++)// 1000의 기준 ㅣ 필연선 그냥 큰 아무 숫자
									// 원한다면 2000이나 다른 숫자 가능
	{
		//i는 쓰지 않는다 (너무 규칙적 :) i 가 안쓰이는 소수의 반복문 중 하나
		// 그 대신 랜덤 위치를 지정하기 위한 변수 두개를 만든다

		int randomA = rand() % 10; // 10: 배열의 크기

		int randomB = rand() % 10;

		// 이어서 데이터를 맞바꾸려면 그냥은 안된다.

		// 맞바꾸기를 위해서 할당하는 순간 두 변수가 같아진다 a= b의 함정

		// 그러므로 한쪽 변수의 데이터를 임시 저장할 {} 속 임시 변수를 또 만든다.
		// (랜덤 위치 변수와 이 임시 변수 : 지역 변수 . {}나가면 사라지는)

		int tmp; // tmp : temparary "임시"

		//그리고 위치 맞바꾸기 실제로 진행
		tmp = arr[randomA]; //랜덤위치 A 순번에 있던 배열 값을 tmp에 전달
		arr[randomA] = arr[randomB]; // 값을 백업한 A순번 자리에 B 순번 값을 전달
		arr[randomB] = tmp; // A 에 값을 넣은 B 자리에는 원래 A였던 tmp 숫자를 전달

		//이러면 B순번 -> A순번 -> tmp -> B순번으로 돌고 돌면서
		//서로 값을 맞바꾸는 것이나 다름없는 결과를 얻을 수 있게 된다

		// 그리고 이 과정을 아주 많이 반복하면 arr 배열에 무질서를 줄 수 있다.

	}
	// 패 섞기가 끝나고 나면 , 배열 출력

	std::cout << arr[0] << "\n";
	for (int i = 0; i < 10; i++)
	{
		

		std::cout << arr[i];

		
	}

	}

