// SGA_240814_PointersAdvanced.cpp

#include <iostream>

// 과제 풀이 (별도 헤더로 작성)
#include "PointerPrincipals.h"     // 포인터 기초 (참조 복습용)
#include "FundamentalsOfPointer.h" // 사칙연산

// 오늘의 문제
#include "ChangeBoard.h"           // '보드 바꿔 보기'
#include "PointerOfChar.h"         // char 자료형의 포인터


int main()
{
    // 0. 지난 과정 되짚기
    //    하나씩 주석을 풀면서 확인해보기

    // PointerPrincipals(); // 포인터 복습
    // HomeWorkSample(); // 과제 풀이의 한 예시
    // TestArrayArguments(); // 보드 바꿔 보기 사전 시험용 함수
    // PointerOfChar();      // 문자의 포인터 사전 시험용 함수



    // --------------------------------------------------------

    // 1. 포인터 더 알아보기


	// 추가 내용 : 포인터의 값의 의미를 다시 돌아보면
	// "주소" 이다 그말은 포인터의 내용은 양이나 척도의 의미가 아니다
	//그보다는 차라리 "좌표" 에 가깝다 

	// 어디에 있는지 어떻게 있는지

	// int = 숫자ㅑ

	// 하지만 int* = 숫자 아님 (숫자 데이터가 있는 컴퓨터의 어딘가란 뜻)


	// 따라서 아래 연산은 성립하지 않는다.

	int a = 0;
	int* aPtr = &a;

	int b = 0;
	int* bPtr = &b;

	int* bptr = &a; // 포인터에 이어 또 다른 포인터가 있다고 할 때
	aPtr = *aPtr + bPtr; // 이렇게 포인터끼리 사칙연산을 할 수는 없다

	// 비유하자면 남대문과 동대문을 덧셈할 수 없는 것과 비슷

	// 대신 좌표로서의 추가 연산은 가능
	//bPtr = aPtr + 1; // 이게 되네? 당연히 된다.

	// 이 역시 비윻자면 동대문에서 북쪽으로 몇 번지 가
	// (현실에 있는 주소는 아니지만) 대략 의미가 성립하는 것과 같다

	// 그러면 여기서 쓰인 1이라는 의미는 무엇일가

	// 바로 int 라는 자료형이 존재하기 위해서 컴퓨터가 점유했던 메모리 공간의 크기/
	// 다시말해 int 변수의 주소의 크기
	//(참고 : int는 4바이트) 그러므로 위 계산에서 쓰인 1은 곧 4바이트

	//aPtr 이라는 int 메모리 주소에서 int 하나만큼의 공간을 건너뛴 것이라는 소리

	// 확인출력

	std::cout << aPtr << std::endl;
	std::cout << bPtr << std::endl;

	// 다른 예시 

	float f = 10.00f;
	float* fPtr = &f;
	float* gPtr = fPtr + 1;

	double d = 100.0; // 더 정밀한 소수 숫자뒤에 f나 d없는게 중요

	double* dPtr = &d;// 그 더 정밀한 소수 (= "배정밀도")의 포인터
	double* ePtr = dPtr + 1;


	std::cout << dPtr << std::endl;
	std::cout << ePtr << std::endl; // 확인 결과 : 배정밀도는 8바이트


	// 2. 포인터의 중첩 

	//- 포인터는 주소를 값으로 가진다
	// - 포인터는 대응하는 자료형의 현재 주소 라는 의미의 자료형이기도 하다
	// (정확히는 먼저 밝혔듯, 포인터라는 말 자체가 포인터 변수의 줄임말)

	// (int 변수 , bool 변수와 같은 맥락이라는 뜻)
	// 포인터는 그러니까 변수다 자료형이 있고 이름이 있고 값이 있다.


	// -> 포인터에는 이름이 있다면 그 이름이 붙은 메모리 주소가 있지 않을까?


	// 따라서

	// int 가 있으면 

	// int의 포인터가 있다 그리고

	// [(int의 포인터 )의 포인터 ] 같은 것도 성립하지 않을까?

	// [(float의 포인터 )의 포인터 ]는 어떨까???

	//있어야 하지 않을까?



	// 정신차리십쇼

	// 답은 있다. 와우


	//포인터는 결국 데이터 그자체가 아닌 데이터가 있던 자리를 표현한 것

	// 데이터? 나중에 역참조로 보면 된다.

	//그러므로 포인터도 변수로서 만들어진다면 , 만들어진 위치만 그냥 보는
	// 포인터의 포인터도 존재할 수가 있는 것이다.

	//ㅎ..화이팅


	//이렇게 중첩되는 포인터를 <다중 포인터>라고 한다.

	// 2중이면 2중 포인터 , n중이면  n중 포인터

	// 다중 포인터의 작성 (위 aPtr를 활용)


	aPtr; // 이건 포인터

	&aPtr;// 이건 포인터가 변수로서 있던자리

	std::cout << aPtr << std::endl;
	std::cout << &aPtr << std::endl;


	// 포인터의 포인터 
	int** aPtr2 = &aPtr; // 포인터의 포인터에 값 할당
	int*** aPtr3 = &aPtr2; // 3중 포인터

	std::cout << aPtr2 << std::endl;
	std::cout << aPtr3 << std::endl;


	// 그리고 포인터가 꼬리에 꼬리를 무는 것이 가능하듯이
	// 역참조 역시 꼬리에 꼬리를 물고 되돌아갈 수 있다.

	std::cout << "---------------------------------" << std::endl;

	std::cout << *aPtr3 << std::endl;
	std::cout << *aPtr2 << std::endl;
	std::cout << *aPtr << std::endl;

	// 그리고 더불어서 포인터의 선언만이 아니라

	//역참조와 참조 연산자 역시 중첩이 가능하다.(*** , &&&)



	// 위에 있던 aPtr3 에 추가로 * 역참조 연산자를 중첩 

	std::cout << *aPtr3 << std::endl;// 삼중 포인터의 역참조
	std::cout << **aPtr3 << std::endl;// 역참조의 역참조
	std::cout << ***aPtr3 << std::endl;// 역참조 역참조 역참조


	// 그냥 뒤로가기 3번 한 느낌임 이해하자 개념 이해

	// 이론적인 개념이지만 이런 관계가 가능하다

	// 포인터 =& 변수 (&는 참조 연산자)
	//*포인터 = 변수(*은 역참조 연산자)

	// 따라서 *와 &눈 방향이 서로 반대인 관계이다.
	// 그러므로 + - 처럼 이 두연산자도 하나로 묶으면 
	// 마치 한 쌍이 사라지는 듯한 느낌이다.

	std::cout << *(&a) << std::endl; // a의 위치 참조에 있던 실제 내용
									// *,& 모두 사라지고 a만 남는 듯한 결과

	// 지금은 말장난에 가깝지만, 이후에 아이디어로 활용될 수도 있는
	// 응용법이므로 살짝 봐두도록 하자 (암기 하자 그냥 )

	// ** 포인터 중첩은 반드시 숙지해야 한다 반드시 반드시 반드시 반드시 반드시 숙지해라

	// 포인터 중첩이 뭐가 중요하길래 자꾸 강조하는가?

	// 1. 포인터 자체가, 참조한다는 행위가단순 위치 파악을 넘어서
	// 실체를 다루려고 쓰는 경우도 있기 때문 

	// 당장 과제로 만들었던 사칙 연산을 해서 숫자를 직접 바꾸는 함수  같은 것이

	// 그렇게 포인터를 활용한 예시]

	//2. 따라서 포인터라는 위치의 내용 이라는 실체를 쓴 다음에
	// 다시 이 연산에 써먹은 변수의 위치 라는 추가 정보가 필요하다면
	// 1중 그냥 포인터만으로는 안된다.. 그래서 2중이상 포인터가 필요


	// 2_1 정도로 필요한 사항은 아닌데 다중 포인터가 있으면
	// 만들기 편해지는 것도 있다. 그게 뭐냐? 


	// - 되짚기 : 포인터를 좌표로 계산하는 것은 가능하다 (+1 +2)
	// 여기서 +1의 단위는 대응하는 자료형의 메모리 크기 
	// 혹은 " 변수의 체급 " 이라고도 표현 가능


	// 되짚기 2 : 포인터의 값은 곧 좌표 . 그곳을 보면 그 자리에 데이터가 있다.

	// 이 두사실을 종합하면......

	// 포인터를 이용하면 여러 데이터를 한곳에 묶어서 집합으로 만들 수도 있겠네?

	a = 100;

	aPtr = &a;
	bPtr = aPtr + 1; // 한자리 뒤에 
	//*bPtr = 200; // 그 자리에 새로운 숫자

	//std::cout << *bPtr << std::endl; // 억까 당함 오류 뜸 근데 이게 맞나봄

	// 오류는  왜 뜨는가 - > 이 메모리 위치에 이름이 없어서 (선언 없음 = 할당 안됨)
	// 이 위치를 기록한 포인터의 이름이 bPtr 이지 해당 위치를 b라고 하진 않음

	// 하지만 그래도 실행은 된다 200 이란 데이터도 확인 가능

	// 다시 말해 먼저 이 자리에 적절한 할당만 있었더라면///


	// 이 위치에 있는 데이터를 오류 없이 읽는 것도 가능했다.

	// 그런디.. 우리는 이미 이 할당을 보았다잉

	// 정확히는 다음 할당을 보았다.

	//??


	// "(자료형이 동일한 ) 여러 데이터를 한곳에 묶어서 집합으로 만든 것

	// 배열이다 

	// 그래서 배열로 데이터를 만들고 나면, 포인터로 접근할 수도 있다.

	int arr[3] = { 1000,2000,3000 }; //배열 3개
	

	// 그리고 이 배열을 어떻게 표현할건가?

	int* arrPtr; // ?? int 하나짜리 .. 그렇죠? 몰라요

	//int* arrPtr[3]

	// 여기서 한가지 c++ 과 c의 추가 개념이 등장한다.


	std::cout << arr[0] << std::endl;

	// 그리고
	std::cout << arr << std::endl;


	// c++ 에서는 배열의 이름 자체가 주소가 된다. 위에 arr은 출력이 된다.
	// 그러므로

	arrPtr = arr; // arrPtr 에 arr 을 할당하면 들어간다. 

	std::cout << arrPtr << std::endl;
	std::cout << *arrPtr << std::endl;

	// 이어서 포인터 주소 연산 결과 출력

	std::cout << *(arrPtr+ 1) << std::endl;// arrPtr  + 1 한 것의 역참조
	std::cout << *(arrPtr+ 2) << std::endl;// arrPtr + 2 한 것의 역참조

	// 실행하면 오류도 나지 않고 (여러 주소에 arr 이라는 이름을 이미 붙였으니까)
	// 주소 연산에 따라 , int 자료형 크기만큼 참조 위치를 이동하면
	// 그곳에 있는 숫자를읽을 수가 있음을 확인할 수도 있다

	// 다른 말로 포인터 변수의 값 +n 은 배열의 [n]과 같다

	// 또 다르게 표현하면 이렇게 표현할 수도 있다.

	//1. 배열은 그 자체가 포인터
	// 2. []연산자의 의미 : 포인터에서 참조할 자료형의 위치를 나타낸 것
	// 그래서 순번 연산자 []의 0 이 첫 번째 원소인 것
	// 역참조한 위치 (+- 0) 딱 그곳에 첫 원소가 있으니까

	// 그리고 이 사실에서 추가로 유추할 수 있는 것

	int* arrPtr3[3] = { arr,arr,arr };// 포인터가 원소인 배열을 만들면

	std::cout << arrPtr3 << std::endl;// 포인터 배열의 위치 출력 (배열 = 포인터)
	std::cout << *arrPtr3 << std::endl;// 역참조 한 번 (포인터의 내용)
	std::cout << **arrPtr3 << std::endl; // 역참조 두번


	// 그런데 arr은 배열이다? 배열속에 또 배열이 있다? 

	// 논리적인 결론: 지금 만든 포인터 배열은 이차원 배열과 같다/

	// 가설 확인

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			//std::cout << *(*arrPtr3 + j) << '\t';
			std::cout << *(arrPtr3[i] + j) << '\t';
			// 위에 arr 배열을 세번쓴 것 때문에 오류났다고 합니다.

			// 하지만 .. 아무튼 i j 이중 반복문을 통하면서 
			// 각각 배열 계산을 하는 것이 가능


			// 정확히는 arrPtr3의  i번째 원소의 다시 j주소
		}
		std::cout << std::endl;
	}
	// 이렇게 만들면 이중 배열로 사용할 수 있음을 확인 가능

	// 나중에 만들어진 1차원 배열을 모아 작은 배열들의 집합으로 구성된 
	//2차원 혹은 3차원 배열을 만들날이 온다면
	// 그 때 다중 포인터가 의외로 유용하게 쓰일 수도 있다.

	// 다만 현실적으로 2, 3중 포인터 이상을 흔히 쓰지는 않는다
	// (배열과 비슷한 경우 . 만들려면 만들 수야 있지만 귀찮아서
	
	// 거의 대부분은 (특히 현재는 )2중 포인터도 잘 쓰지 않을 것
	// 따라서 다중 포인터를 통한 다차원 배열.. 등은 일단은 눈도장만

	// 나중에 코딩 테스트 등에서는 쓰입니다. 차근차근 꾸준히 봐둡시다.

	// 다만 재차 강조 : 다증 퍼인터의 사용법 (int** int ***) 그리고

	//배열이 포인터다. []가 포인터 관련 연산이다 라는 개념은 

	// 이 기회에 꼭 알아둡시다.
 

}
