#pragma once


//주석 불필요 : 자가 검색을 더 추천

// 메모리 구조

// 컴퓨터는 앱을 실행하면 그 내부에 존재하는 프로그래밍 지시들을
//코드에서 용도에 따라 구분을 한다

// 그리고 코드의 구성, 목적, 지시한 작업 등에 따라
// 메모리 안의 다른 영역에 각각 나누어 배치를 한다

// -> 그래서 빠르고 반복 작업은어려운 곳, 느리지만 마음대로 편집 가능한 곳
// 하는 식으로 영역끼리도 용도를 나누어서 효율적으로 실향하고자 한다.

// 이 때 컴퓨터가 스스로 설정하는 메모리의 구조중 ,
// 앱을 실행에 관여하는 부분은 다음 네가지로 구분된다.

//1. "코드" 영역

//프로그램을 구성한 원본 코드 내역(텍스트) 그 자체를 담아두는 공간
//모든 것의 기초라고 할 수 있고, 실행 증에 참조할 데이터가 필요하면
// 여기서 코드를 다시 보고 실행한다. 가장 빠르고 가장 편집이 힘들다

// 엔드 (최종 실행용 앱)프로그래머. 특히 게임 프로그래머 입장에서는
// 사실상 손 대기도 힘들고 손댈 필요도 없는 영역이기도 하다.

//2. "데이터" 영역

// 프로그램을 최초로 구현하기 위해서 꼭 필요한 데이터를 담아두는 공간
// 구체적으로는 함수 지시사항 , 전역변수 ,(나중에 알아볼) "정적 변수" 등을
// 이 영역에 저장한다. 코드와 마찬가지로 한번 실행되고 나면 
// 앱이돌아가는 중에는 사실상 수정이 없는 거나 마찬가지 

//	보통은 메모리의 부담을 줄이거나, 반대로 메모리의 부담을 늘려서라도
// "빠르게 보고 참조할 수 있는 데이터를" 를 만들어주기 위해서
// 전역변수를 추가하거나, 빼는 방식으로 이 영역에 간접 개입을 하는 편

// 그러니까 , 전역변수가 많아진다 = 사양 높아짐 , 속도 빨라짐/
// 전역변수를 줄이고 함수 안에서 변수를 만들고 지운다(지역변수 )= 사양 낮아짐 , 느려짐

//이 다음부터가 실질적으로 어떤 프로그래머든 신경쓸 대상

//3. "힙" 영역(heap, 축적)

//코드를 통해서 사용자가 미리 만들어두라고 컴퓨터한테 시킨 데이터가 들어간다.
// 대표적으로'new' 지시를 써서 만든 인스턴스 포인터 객체
// 그 밖에도 함수가 힙에 들어가는 데이터를 발생시키기도 한다.
//이렇게 사용자의 지시에 의해서 컴퓨터가 일부러 이쪽에 할당한 데이터를
// "동적 할당 데이터"라고 통칭한다.


// -> 데이터 영역처럼 힙도 실행전에 어느정도 사용자의 의지에 따라 부담량이 달라진다.
// 힙이 많다-> 메모리에 담긴 데이터가 많다 = 여유 공간이 적다.

// 다만 힙은 데이터보다는 참조가 느려서 힙을 쓰고 안쓴다고 속도가 큰 영향을 받진 않고
// 대신 "여유 공간"의 존재가 큰 변수가 된다


//(재정리)힙이 많다 = 여유 공간이 적다 = 실행중에 프로그램에서 발생하는
// 추가 데이터가 많을 경우 (게임의 하이스코어라든가 채팅로그라든가)
// 프로그램이 큰 부담을 받을 수 있다.

//	반면에 프로그램이 힙을 많이 주면 줄수록 프로그램의 실행에 필요한 기반 데이터가
// 충분히 확보된 것이기 때문에 실행중에 오류나 로딩 문제등이 발생하지 않은
// = 안정성도 높아진다. (게임으로 치면 랙 감소)

// 장단점에 따라 힙을 얼마나 쓸 것인지 정하는 편이 나중에 
// 간단히 말하면, 최적화 단계에서 같은 데이터를 힙에 둘건지 다른 곳에 둘건지
// 이 부분을 정하는게 프로그래머의 과제가 될 것.

// 이런 영역에 이어서, 마지막으로 프로그램 자체에서 스스로 발생시키는 영역이 ...

//4. "스택" 영역

// 실행중에 앱이 발생시킨 데이터들 (컴파일에 의한 생성 데이터 ,지역변수 , )
// 동적할당 시에 만들어진 실질 데이터 말고 그 데이터를 담은 '포인터' 변수)
//	앱 실행 중에 추가로 나온 데이터라면 무엇이든. 순간적인 보스의 체력 변화, 채팅로그
//이 모두가 무엇이든 메모리에 쌓여서 관리되는 곳이바로 스택 (stack, 적재)이다

// 컴퓨터 입장에서는 가장 자유롭게 다루는 메모리 영역이지만 , 가변성이 높아서
// 그때그때 어떤 데이터가 어디에 있는지 가장 알아보기 힘든 곳이기도 하다.

//= 스택 비중이 높다 = 가장 느리다 = 가장 메모리 사양 요구가 낮다.
//									적은 메모리로 시작할 수 있어서

// 이 밖에도 코드 실행 중에 컴퓨터가 만들게 되는 새로운 변수...
// 실행중에 반복문 과정에서 발생하는 연산의 결과
// 나중에 우리가 배열의 크기를 (혹은 문자열의 길이를) 마음대로 할 수 있다면
// 그 때 추가하라고 시킨 새 문자들 ... 이 데이터들도 마찬가지로 스택으로간다.

// 요약: 실행하고 나서 만들어질 (혹은{}안에서 선언이 시작된 변수들
//	이런 데이터들은 모두 스택이라고 우선 생각해도 괜찮다.

// 프로그래머 입장에서도 가장 만만하면서 동시에 가장 무서운 메모리 영역

// -> 만만하다 = 기본 요구 사양이 낮기 때문 (그냥 함수 안에서 아무거나 만들면 OK)

// -> 무섭다 = 반복문 잘못돌리면 연산하다가 앱이 오류날 수도 있기 때문
	//				(반복문에서 너무 많은 연산을 하다가 오류 나본 경험 있는 분?)

//-> 그리고 스택이 데이터 양을 감당 못해서 터져 나가는 형태의 오류를
// 스택 과부하 (stack overflow) 라고 한다


//==============================================================================================================


// 메모리 영역을 알아보고 나면 지금 우리가 알 수 잇는 사실

//1. 전역변수는 만능이 아니다.(다 전역변수로 만들면 앱이 느리다!)

// 옛날에는 사양도 문제였지만 .. 지금은 그런 시대는 아니고

// 2. 앱이 얼마나 많은 메모리를 쓰는가는 우리 코드에 달렸다. (원론이지만)

//3. 어느 정도 범위 안이면 우리가 실행할 앱이 컴퓨터 메모리를 얼마나 쓰게 할지
// 그냥 마음대로 늘렸다 줄였다 할 수도 있고 그래도 된다. 범위 안이라면

//=> 적절한 기능만 있다면 , 우리는 데이터 자체의 집합 , 배열등을
// 손아파요..

// 마음대로 늘렸다 줄였다 해도 괜찮았다. 단지 그런 기능을 몰랐을뿐.
