

#include <iostream>
#include "processor.h"

int main()
{
	//지시의 예 " typedef(데이터 , 연산 명명 )

	//변명하지마!!!!!!!!!!!!!!!!!!!!!!!!!
	//떽!!!!!!!!


	// 다른 지시


	//1. 자료형의 이름 : 이것도 사실 지시다
	//					지시를 함으로써 데이터가 무엇으로 분류되는지 지목

	//2. 코드의 영역(struct)


	//3. using : 네임 스페이스를 지금 사용하고 있다는 지시
	//				다라서 사용중인 네임스페이스의 이름은 생략가능

	// 4. 현재 권장안함 (auto) : 템플릿처럼 자료형을 미리 지정하지 않는단 뜻
	//							컴퓨터한테 자료형 판단을 위임한다/
	//							앱이 알아서 자료형이 뭔지 멋대로 판단한다.


	auto a = 10.5f; // 실행했을 때 ㅏ마 앱이 소수인 걸로 치지 않을까
	char word[9] = "computer"; // 믄자열
	auto let = word[3]; // 실행했을 때 아마 앱이 글자나 정수로 치지 않을까?
	std::cout << let << std::endl; //출력하면 앱은 글자를 출력	
									// 문자 배열중 하나니까 글자겠거니

	// 자동으로 자료형을 찾아주기 때문에 복잡한 코드를 쓸 댸
	// 개발자가 자기 코드를 100% 정확하게 이해도 하고 있다면 좋은 지시가 되지만
	// 그렇지 않다면 의도와 다른 데이터가 나올 위험도 있어서 auto는
	// 완전히 자기가 c++ 혹은 자기가 쓰는 환경을 익숙하게 여기긱 전에는 비추

	//------------------------------------------------------------------------


	//*팁 : 비주얼 스튜디오 . 기본 색 테마 c++언어일 떄 지시 쉽게 확인하는 법
	//		파란색이면 지시이다
	//-----------------------------------------------------------------------



	//전처리기(processor) : 지시 중 , 앞에 # 연산자를 붙여서
	//						별도 과정에서		작업하게 만든 것

	// 구체적으로는 파일이 실행되기 전 , 혹은 실행 파일이 만들어지기 전
	//(이 작업을 컴파일이라고 한다) 미리 # 지시어부터 맨 먼저 수행부터 하고 본다.

	//* 번역이 원문과 전혀 다른이유 (맨 먼저 처리한다고 "전" 처리기라고 부른다.

	//-> 전처리기에 대한 추가 소개는 별도 헤더에서 진행
	// -> processor.h



	//--------------------------------------------------
	// 헤더에서 만든 전처리기 (매크로 , 조건문 )테스트

	int arr[ARRAY_SIZE]; // 매크로를 사용한 배열 선언
							// []안에 우리는 ARRAY_SIZE라는 단어를 넣었지만
							// 컴파일을 하면 저 자리에는 10이라는 숫자가 들어간다.

	for (int i = 0; i < ARRAY_SIZE; i++) // 여기서도 매크로가 10으로 바뀔 것
	{
		arr[i] = i; // 숫자를 할당해주고

		std::cout << arr[i] << std::endl;


	}

	//여기서 매크로가 쓰이면 좋은 점
	//1. []안에 숫자가 아닌 이해할 수 있는 단어를 넣어줄 수 있게 된다.
	// (그냥 변수는 이게 되던가?)

	int size = 10;

	//int newArr[size]; //  원래 이 자리는 상수만 올 수 있다 = 변수 불가능

	// 하지만 매크로를 []안에다 쓰면 => 매크로는 변수가 아니므로 괜찮다
	// (매크로는 그저 텍스트 변환일 뿐 .컴파일 하면 10이라는 숫자로 바뀌니까)

	//2. 나중에 코드 수정 중에 배열의 크기를 바꿔야 한다면???
	// -> 매크로를 썼다면 그 매크로가 있는 곳으로 가서 숫자만 바꿔주면 된다.
	// (안썼으면 배열 선언에도 . 반복문에도 모두 숫자를 바꿨어야 하지만)


	//물론 어디까지나 텍스트를 바꾸는 것 뿐이기 때문에 만능은 아니지만
	// 매크로 역시 다른 코드처럼 , 잘쓰면 편하다

	//-------------------------------------------------------------

	// 매크로의 다른 사례

	SUTJA number = 100000; // int 같은 자료형 이름이 아닌 매크로를 썼지만 ...
						// 컴파일을 하면 매크로에 의해 SUTJA란 단어가
						// int로 바뀐다. 그러므로 실은 ing number와 같다

	std::cout << number << std::endl;
	std::cout << (short)number << std::endl; // SUTJA 의 단어가 int임을 확인
												// int가 맞다면 short자료형으로 바뀐다	
												// 버려지는 데이터가 나오고,

	//short : 먼 과거 int 자료형이었던 '작은 정수' 를 담기 위한 자료형
			// 차지하는 메모리가 int의 절반(2바이트) 따라서 최대 65535까지 지정가능
	//		(65536/2 * -1)부터(65536/2 * 1)까지 지정가능


	// -> 이렇게 매크로를 사용하면 코드로 작성해야 할 숫자 , 혹은 명령어, 혹은
	// 다른 연산이라도 지정을 해서 편하고 친숙한 단어로 바꾸어 두었다가
	// 일괄 호출, 일괄 수정 등에 활용할 수 있게 된다.

	//매크로의 텍스트 변환 기능 확인

	const char* sayHello = TEST_STRING; // 컴파일 시에 큰따옴표까지 포함해서 ,
										// 모두 변환을 시켜줄 것이다.

	std::cout << sayHello << std::endl;

	//const char* notword = IAMHERE; // 변환할 텍스트가 없고, 있다고 쳐도 연산자도 없어서
									// 맞는 데이터로 취급되지 못한다


	//-> 하지만 IAMHERE 라는 맴크로가 존재는 한다 그게 중요
	//=================================================================


	//전 처리 조건문 써보기
	// 일반 조건문

	if (CONDITION_A > 0)
		std::cout << "일반 조건문 실행" << std::endl; // 한줄 조건문 ={} 생략가능

	// 전처리 조건문을 사용하면///


#if CONDITION_B>0 // 전 처리기는 줄 단위로 코드를 읽는다
					// 별도의 코드 범위를 지정할 수가 없다.
	std::cout << "매크로, 전처리 조건문 실행" << std::endl;
#endif				// 그래서 조건문이 끝날 때 끝났다고 해줘야 한다
	// #endif가 그 명령어


#if CONDITION_A>10000
	std::cout << "전처리 다중 조건문 결과 1번 " << std::endl;
#elif CONDITION_A>1000
	std::cout << "전처리 다중 조건문 결과 2번 " << std::endl;
#else
	std::cout << "전처리 다중 조건문 결과 3번 " << std::endl;
#endif
	// -> 전처리 매크로 조건문을 작성할 경우, 조건에 해당이 안될 것 같은 코드는
//	비주ㅠ얼 스튜디오 작업시 , 텍스트가 어둡게 나온다, 그리고 실행파일 빌드시엔
//	 그냥 텍스트가 사라진다 *(어차피 작업도 안 할 것)


	// 전처리 조건문은 변수를 감지할 수 있을까????????

	int condition = 10;

#if condition > 0
	std::cout << "일반변수 + 전처리 조건문 " << std::endl;
#endif

	// -> 전처리 조건문도 변수가 "있음"은 감지할 수 있다. 하지만,...
	// 해당 변수에 어떤 데이터가 있는지는 알 수 없다. 왜??
	//condition에 10 이라는 숫자를 넣기도 전에 , 이미 전처리기를 먼저 돌리니까
	// 사실상 감지할 수 없는 것이나 다름없다.

	//-> 따라서 전처리 조건문도 완전 만능은 아니고, 매크로와 같이 사용했을 때
	// 가장 적절하게 쓸 수 있다.

	//-----------------------------------------------

	//-> 매크로 조건문은 그러면 매크로 비교에만 쓰는가?

	//-> 한가지 사용처가 더 있다. 바로 .... " 매크로로 선언된 특정 키워드 감지"

	// 다른 말로 " 특정 단어가 매크로로 선언된 적이 있는가?" 여부에 따라
	// 조건문 실행 가능.

	// 자지마요!!!!!!!!!!!!

		
#ifdef IAMHERE			// #ifdef : "해당 매크로가 존재하는지"만 보는 조건문
						// 아까 우리가 적은 '데이터ㅗ 없는 매크로 사용해보기

	std::cout << "나는 여기에 있다" << std::endl;

#endif // #define 뒤에 따라오는 데이터 없는 매크로와 같이 사용했을 때.

	//사용자 (프로그래머)는 자기 프로젝트에 키워드를 부여하고
	// 해당 키워드가 있을 때만 동작하는 코드를 이렇게 준비할 수 있다.

	//-> 그래서 이런 매크로 선언을 활용한 조건문에 자주 사용되는 키워드가 
	//DEBUG라는 매크로다 . (자동완성 키워드)

#ifdef DEBUG // 왼쪽의 DEBUG가 매크로로 선언됏으면 아래 코드가 수행
	//	여기서 디버그 전용 코드 작성

#endif

	//이렇게 전처리기 조건문 활용 가능.

	//-----------------------------------------------------------------------------

	//조건문에 else가 있듯이 , 조건 지정에 != 연산자가 있듯이..
	// 키워드에도 매크로 선언 감지와 같이 쓸 수 있는

	// "해당 매크로가 선언된 적이 없으며 수행되는" 조건문이 존재

//#define YOUAREHERE // 주석 지우면 밑에 실행
#ifndef YOUAREHERE // YOUAREHERE가 없으면 수행되는 조건문
	std::cout << "너는 여기에 없당께" << std::endl;
#endif // !YOUAREHERE 


	// 일어나라!!!!! 엎드리지 마라!!! 일어나라!!!! 코드 써라!!!!!!! 키보드쳐라!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	// 누나 일어나!!!!!!!!!

	//-----------------------------------------------------------------

	//마지막으로 매크로로 어떤 키워드를 선언했는데, 취소한다면?
	// -> #undef

#undef IAMHERE // 아까 작성한 매크로 취소

#ifdef IAMHERE	// 매크로가 헤더에 작성됐지만 , 지금 취소 됐으므로....
	std::cout << "안녕히계쇼" << std::endl;

#endif

	//-----------------------------------------------------------------------


	// 여기까지 코드 작성으로 알 수 있는 것

	//1. 전처리기가 실행이 된다는 것

	//2. 전처리기 실행 시점은 코드 수행보다 더 일찍이라는 것 (중요!)
	// -> 조건문이 안 맞으면 텍스트가 까매짐 (사라짐)
	// => 변수의 값을 읽짐 못함 (할당하기 이전에 전처리기 실행)

	//3. 매크로와 조건문 작성 방법과 활용


}
