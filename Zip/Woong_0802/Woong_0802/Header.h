#pragma once


// 이것이 헤더 파일 : C++ 파일에서 참조하기 위한 머릿말 집합

// 혹은 이렇게 부를 수도 있다" 먼저 정의된 데이터 이름의 목록"

// 혹은 사용가능한 기능의 집합" 이라고

// 여기서 작성된 함수의 이름은(사실 이름만 아니라 내용도 마찬가지)

// -> cpp파일에서 부르면 쓸 수 있는 대상이 된다.

//====================================

// 작성해보기


// void 함수 이름 만들기

void TestFuntion();  // 시험용 함수 

int TestSum(int x, int y);	// 시험용 더하기 함수

void HeaderFunction() // 헤더 함수라는 이름의 함수

{

	std::cout << " 이 함수는 헤더에서 내용이 전부 작성되었습니다" << std::endl;
	std::cout << "이에 따라 실행도 헤더에서 될 것입니다" << std::endl;
}

// 위 함수가 되는 이유  : 결국 헤더에서 내용을 다 만들었다는 이야기는
// 이 헤더를 불렀을 떄 , 그러니까 main()가 시행되기 전에
// 컴퓨터가 이 함수의 내용까지 모두 파악했다는 의미
// 그렇기 때문에 여기서 만든 함수를 main()dptj Tmsmsep dkan answprk djqtek

// 원래는

// 그럼 문제가 있다는 말인가? 사실 있다, 컴퓨터가 아니고 사람한테 있다

// 헤더의 목적이 코드를 나누어서 간단하게 보기 위해서인데

// 그 헤더 안에 모든 함수 , 모든 변수를 다 넣어버리다 보면
// 나중에 사람이 도로 헷갈린다.

// 그 때문에 (어차피 나중 가면 불가피하게 몇몇 함수는 내용을 적을 수 밖에 없지만)
// 가능하면 , 되도록, 최대한 , 헤더에는 함수의 이름 등 목록만 적어주고
// 해당 함수의 구체적인 내용은 cpp에서 확인 할 수 있도록 만들어주면 좋다고 한다

// 이것이 c++ 개발의 지침
// 이를 헤더와 코드 , 혹은 선언과 정의 분리라고 한다.

// 이를 실천하기 위한 함수를 하나더 


int EXP(int number, int expCount);// 거듭제곱 함수를 선언만 

// 헤더 기능의 마지막 : 변수 

// 헤더는 함수만 아니라 변수도 작성 가능

// 선언도 가능 , 초기화 (할당) 도 가능

int headerNumber = 1000;// 헤더에서 곧바로 변수 다 만들기

int justNumber; // "그냥 숫자"는 선언만 하기

// 헤더 파일을 통해 알 수 있는 것
//
// = 헤더 파일 사용 정리

// 1. 그냥 여기에 코드를 적으면 다 읽힌다

// 2. 하지만 간편한 정리를 위해 여기는 되도록 이름 위주로 간단히 선언만 해준다

// 3. 선언의 대상은 변수 , 함수 무엇이든 가능













// 코드가 길어질 때 청소하는 법 : 변수가 있을 자리 바꾸기

// 코드를 적다보면 변수가 너무 많을 때도 있다
// 그리고 직접적인 관련은 없지만 ... 변수를 만들다 보면
// 나도  모르게 같은 이름을 여러 번	만들 수도 있다

// 이때 생기는 중복의 문제 , 귀찮음의 문제를 해결하기 위해서
// 코드의 자리를 바꿔주는 것도 가능한 해결책 중 하나다

// 무슨 말인가? 하면

// 변수는 만들어지면 모든 자리에서 똑같이 인지되지 않는다.

//정확히는 변수는 자기가 만들어질때 계층 혹은 위계라는 개념을 갖는다
// 그리고 이 계층이 자기가 있는 곳과 그 미만 계층에서는 컴퓨터에 인지된다
// 그 밖에서는 이 변수가 없는 것으로 취급된다

// 간단한 말로 표현하면 변수는 자기가 만들어진 {} 안에서만 인지된다

// {}룰 벗어나면 해당 변수는 인지되지 못한다

// 이를 확인하기 위한 테스트 함수를 헤더에 만들고 호출한다
// 그렇게 {} 안에서 만들어져 {} 안에서만 인지되는 변수를 통틀어서

// 요약 : {}안에서 만들어진 변수는 다른 함수에서 사용 할 수 없다.

// 따라서 제어문 (조건문과 반복문의 통칭) 에서도 마찬가지



