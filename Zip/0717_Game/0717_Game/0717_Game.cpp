

#include <iostream>

int main()
{
	//이 {} 사이에 코드를 작성하면 컴퓨터가 알아듣고 실행한다
	//그러기 위해서는 컴퓨터가 알아들어야 할 대상이 무엇인지 가르쳐주어야 한다.
	// 이 과정에서 컴퓨터에게 우리는 "이런 자료가 있다. " 라는 의미를 전달한다.
	//이렇게 전달해야 할 자료 다시 말해서 ㅇ리가 지정하는 지시대상을
	// 우리는 "변수" 라고 한다. (Variables, 우리 말로는 "지시한 대로, 바뀌는 것")
	//변수를 컴퓨터에게 가르치는 방법ㅡ 혹은 "변수 작성 방법은" 아래와 같다.
	// 첫 예시
	int n = 0;
	// int: 지금부터 지시하는 대상은 곧 숫자라는 뜻 (integer, 정수) 라는 뜻
	// n: 변수의 이름 , 지시한 대상에 우리가 임의로 붙인 이름(바꿔도 된다.)
	//0: 변수의 정체. 혹은 "변수의 값"이라고 불리는, 진짜 자료의 내용
	// 따라서 위 한줄을 해석하면  "지금부터 0이라는 숫자를 잘 기억하세여/
	//그리고 이 숫자를  n이라는 이름으로 부르겠습니다
	// 따라서 나중에 우리가 n 이라고 다시 부르면,(나중에 n이라고 그냥 말하면)
	//컴퓨터 당신은 0이라고 이해하십쇼(너는 0이라고 알아들어라)
	// 도식화하면 아래와 같다.

	//변수의 유형.  "변수의 이름 = 변수의 내용 이렇게 나뉜다.

	// 여기서 int  다시 말해서 변수의 유형이란?
	// 컴퓨터한테 지시를 할 떄 이 자료가 어떤 형태로 분류되는지를 가르쳐주는 것
	// 컴퓨터가 기본적으로는 0과 1밖에 알지 못한다
	// 더 복잡한 기억이 필요하면 더 많은 0과1을 조합해서 신호를 조립해야한다
	// 그래서 각 자료마다 효율을 위해서 몇개의 0과 몇개의 1을 써서
	// 어떻게 분류를 해야 되는지를 미리 정해둔 목록이 있다.
	// 그 목록을 다시 프로그래밍 언어의 용어로 지칭한 것을 "변수의 유형" 이라고 한다
	// 원문은 Type of Data 혹은 Data Type -> 직역해서 "자료형" 이라고도 한다.

	// -------------------------------------------------------------------------

	// int 이외의 다른 자료형
	// float 주의 소수 뒤에 f 붙일 것 
	//(정수표시일 땐 f 붙으면 에러나지만 , 그래도 가능하면 하기)
	// 컴퓨터 입장에서 연산의 '망설임'을 줄여서 빠륵 만들기 위해서
	//(특히 나중에는 f가 없으면 반드시 오류가 나는 경우도 있다.)
	float f = 0.5f; // float는 소수(소수점이 어딘지 모르는 소수)
					// 소수점 밑으로 아주작게 연장되는 소수나
					// 아주 큰 소수를 계산하기 위해서
					// 1.xxxxxx....로 표현되는 단순한 숫자와,
					// 이 숫자에 10을 몇 번 곱할 것인가로 조합된
					// 다소 복잡한 소수의 1차 연산을 한 세트로 사용한다.
					// 예 : 78.9라는  소수는 7.89라는 본체와 (지수라고 한다)
					// 10을 한번 곱한다는 연산으로 이루어진다.
					// 이 과정에서 소수점이 숫자의 어디에 있어야 하는지가 
					// 매번 바뀌기 때문에, 이 자료형을 "소수점이 붕 뜬 소수" 라고 한다.
					// = 부동 소수 (float , 붕 떠 있음, 부동)


	int Woong = 5;



	// 실수는 자료형이 없다. 컴퓨터는 무리수가 뭔지 모름 알긴하는데 연산 못함(바보)
	// 그 대신, "아주 아주 큰 숫자" 는 다룰 수 있다.

	long l = 999999999;
	// 아주 큰 숫자.. 를 뜻해야 하는데 , 사실은 int 와 다를게 없다.
	// 컴퓨터가 발전하면서 long 과 int의 처리 범위가 같아졌다.

	long long ll = 9999999999999;//이쪽이 아주아주 큰 숫자용 자료형


	double d = 555555555.5;
	// double은 float와는 비교가 안될 정도로 큰 소수 자료형
	// 또는 아주 작은 소수 자료형도 됨

	// 숫자 말고 다른 자료형
	// 문자 

	char c = '박';// char : 글자를 뜻하는 character의 첫 네글자 인명아님 
					// * 이 자료형에는 값 앞뒤에 따옴표를 '' 를 붙여서 글자임을 나타낸다.
					// -> 컴퓨터가 글자를 숫자와 헷갈리기도 한다. (0과 '0'의 차이)

	//문자열  문자 하나가 아닌 , 여러개.... 는 c++에 아쉽지만 없다.
	// -> 대신, 나중에 여러개의 자료 , 변수를 동시에 처리할 수 있는 수단드이 있다.
	// 그 수단을 쓰면 문자를 문자"들"로 사용할 수 있다.

	//논리

	bool b = true;
	bool bx = false;

	// 논리 자료형 : 불리언 (Voolean )이라는 학자가 창안한 자료의 유형
	// 실체가 있는 자료로서가 아니라, 어떤 질문을 컴퓨터에게 하거나 받았을 때 
	// 그 대답인지 "예" 인지 "아니오"인지 판별하고 기록하기 위해서 만들었다.
	// 매우 빈번하게 쓰이는 1등급 중요 자료형이다.

	// 이렇게 자료형을 컴퓨터에게 입력을 해주면 .., 컴퓨터는 이를 기억한다.
	// (딱 앱이 끝날 때 까지만.)
	// 그리고 앱이 실행되는 도중에 이 자료형으로 지정된 변수를 출력하려고 시키면,
	// 컴퓨터가 변수의 이름으로 지정된 자료의 내용과 정체 (=값)을 출력해준다.


	// 다른 지시는 더 필요 없이 , n을 그대로 지정하고 출력을 시켜도 된다.
	// n이라는 변수의 이름을 적으면 그 내용을 컴퓨터가 보여줌
	// 다른 자료형도 출력
	std::cout << Woong << std::endl; // 인트 값 내가 실험용으로 적음
	std::cout << f << std::endl;// float 소수
	std::cout << l << std::endl;// long 큰 인트
	std::cout << ll << std::endl;// long long 완전 큰 인트
	std::cout << d << std::endl;// double 더블 작거나 큰 소수
	std::cout << c << std::endl;// char 문자 
	std::cout << b << std::endl;// bool 불값 true값 
	std::cout << bx << std::endl;// bool 불값 false 값

	// 출력 후에 확인 가능한 특이사항
	// -> bool 자료형은 화면에 출력하면 숫자가 남는다
	// 1이면 true 0이면 flase 값


	std::cout << "============================" << std::endl;

	// 변수 이름 정할 때 철칙
	// 무슨 일이 있어도 ... 
	// 1. 변수의 첫 번째 글자는 숫자로 하지 말 것
	// 2. 변수의 이름은 중복시키지 말 것 (특정 조건에서는 어겨도 되지만 지금은 아님)
	// 3. 아래에서 설명해주신다 하셨음.

	// 변수를 컴퓨터한테 가르쳐준 다음에는 이것들을 사용해서 계산도 할 수 있다.
	// 원래 이거 하려고 컴퓨터 만들어짐.

	// 그렇게 계산이 하기 위해서, 컴퓨터에게 지시하는 용도로 부호를 입력하며,
	// 이렇게 쓰이는 부호를 연산자(operator, opCode "연산 부호")

	// 연산자의 종류 및 예시 


	//1. 산술 연산자 ()


	// + : 더하기

	int j = 8;
	int wg = 5;

	int jwg = j + wg;

	std::cout << jwg << std::endl;

	int sub = j - wg;
	std::cout << sub << std::endl;

	// *, / : 곱하기와 나누기
	// * (시프트 8) : 컴퓨터가 쓰는 곱하기 부호
	// / (슬래시 1회 ): 컴퓨터가 쓰는 나누기 부호
	// % : 정수 나누기 계산을 했을 때 , 생기는 나머지

	int mult = j * wg;	// mult : 곱하기
	int div = j / wg;	// div : 나누기
	int rem = j % wg;	// rem : 나머지 연산자

	std::cout << mult << std::endl;
	std::cout << div << std::endl;
	std::cout << rem << std::endl;

	// = : 자연스럽게 썼지만 이것도 사실은 연산자. 이름은 할당 연산자
	//  변수의 이름을 지정하고 내용을 설정하는 과정을 "할당" 이라고 한다.
	// 
	// <,> : 비교 연산자
	// 모양 그대로 왼쪽과 오른쪽중에서 어느 쪽이 더 큰가를 가린다.
	//	연산의 결과는 제시한 식이 말이 되는가 , 되지 않는가를 따지는 연산자.
	//	비교 연산의 결과는 bool

	// == : 같다 
	// != 다르다
	// <=

	bool c1 = j > wg; // c1의 뜻은 j가 wg 보다 큰가? 를 따지는 불값
	bool c2 = j < wg; // c2의 뜻은 j가 wg보다 작은가? 를 따지는 불값
	bool c3 = wg > j; // c3 의 뜻은 사칙연산처럼 같은 연산인데(연산은 됨) 두자료의 위치가 바뀜 
	bool c4 = wg < j; // 결과가 달라지는 경우가 있음

	std::cout << c1 << std::endl;
	std::cout << c2 << std::endl;
	std::cout << c3 << std::endl;
	std::cout << c4 << std::endl;


	// 비교 연산의 확장: "크거나같다 " 작거나 같다"
	// 컴퓨터는 세로로 겹쳐 쓰기가 안돼서 = 부호를 오른쪽에 쓴다.
	// 무조건 왼쪽

	int aa = 100;
	int bb = 100;

	bool cc1 = j >= wg;
	bool cc2 = j <= wg;

	bool aabb = aa <= bb;
	bool bbaa = aa >= bb;
	std::cout << aabb << std::endl;
	std::cout << bbaa << std::endl;


	// ============================================================


	// 2. 논리 연산자 

	// 논리 연산자는 기본적으로 비교 연산자와 닮았다. (맞냐 틀렸냐만 본다.)
	// -> 다루는 대상도 철저하게 같은 노리 자료형만 다룬다

	// 예 : 조건2개가 모두 맞아야 되는 경우 , 각 조건이 맞는지 별도로 계산한다.
	// 혹은 /// "새집은 어디에 있어야 되고 지하철역이 가까워야 되고"

	// &&: 논리곱 , 혹은 " 하나라도 틀리면 안쳐줌"

	bool condition1 = true;
	bool condition2 = false;

	bool myanswer = condition1 && condition2;

	std::cout << myanswer << std::endl;// 위 두줄이 모두 true여야 이것도 true

	// ||(백스페이스 왼쪽) \ 키를 시프트 누르고 누르기
	//	: 논리합 , 혹은 "하나만 맞춰도 맞는 걸로 치자!"
	//			혹은 "둘다 틀려야 틀린걸로 치자"

	bool imkind = condition1 || condition2;
	std::cout << imkind << imkind<<  std::endl;

	// ! : 부정, 뜻은 "이거 아님" 
	//    더 정확한 뜻은 다른 변수에서 지정된 bool결과의 역전 

	bool iamnot = !condition1; // ! 표시의 위치가 변수 이름 왼쪽인 것이 특징
	std::cout << iamnot << std::endl;

	//== : 일치 , 왼쪽과 오른쪽이 같다고 주장하거나, 같은지 판별
	//		

	bool identical = condition1 == condition2;
	std::cout << identical << std::endl;

	// != : 불일치 " == 아님!"

	bool different = condition1 != condition2;
	std::cout << different << std::endl;

	// 일치와 불일치의 경우 왼쪽 = 표시와 오른쪽 = 표시의 결합으로 봐도 된다.
	// 말하자면 1. 오른쪽 (=)는 왼쪽이 곧 오른쪽임을 나타내는데
	// 2. 그래서 진짜로 그러한가? (=) 아니면 그게 아닌가? !로 판별가능
	// 
	// 다음 연산자
	// 
	// 3. 지정연산자: 본 연산을 보조해서 , 추가 조건을 설정하는 용도 
	//{} : 영역 지정 연산자 (코드의 시작과 끝을 나타낸다.)

	// () : 호출 지정 연산자 (경우에 따라 다목적)
	//		어떤 곳에서 쓰느냐에 따라 구체적인 의미는 다른데...

	// 공통적으로 의미하는 것은 "일단 여기부터 확인하시고 " 라는 뜻
	//()의 예시 

	int ex1 = 1 + 2 * 3; // 예상 값은 7
	int ex2 = (1 + 2) * 3; // 예상 값 9
	int ex3 = 1 + (2 * 3); // 7

	// () 다른 예시 

	char letter = 'D';
	int codeOFLetter = (int)letter;
	std::cout << codeOFLetter << std::endl;

	// char로 처음만든 letter 변수의 값은 원래 D이다 강제로 변환되어서 정수값으로 변환 
	// 마치  int 인 것처럼 숫자인 것처럼 컴퓨터의 인식을 바꾸어서 연산을 시킬 수 있다

	// 사용은 변수 이름 앞에 ()를 붙이고 안에 원하는 새 자료형을 넣으면 된다
	// 이렇게 () 를 써서 자료형에 대한 컴퓨터의 인식을 바꾸는 과정을
	// 자료 유형 바꾸기 , 혹은 "형 변환" 이라고 한다.

	// () 아 밖에도 ()에는 다른 용도가 있음 다음시간에 계속...

	// 이 외에도 매우 많은 다른 연산자가 c++에도 존재한다.
	// ; ^ @ # : . ->   [] * $ ?
	//:: << >> 이것들도 사실 연산자 


	// 변수 작명 철칙 3번째

	// 3. 변수의 이름에 절대 연산자 쓰지 말 것(연산인지 변수 이름인지 헷갈리니까)
	// -> 다른 말로 " 표시 외에 어떤 특수 문자도 쓰지 말 것 "
	// 위에서 소개된 "기타 연산자" 가 쓰인 사례소개

	// <<..... 에 대응하는 반대쪽 연산자 '>>'
	// 구체적인 설명은 차후에 다시 설명, 지금은 이렇게 요약 가능
	// "외부의 데이터를 컴퓨터에게 주입가능"

	int input;// 변수는 값을 할당하지 않고 이름만 정해줄 수 있다.
	// 이것을 선언이라고 한다(declare)
	//이렇게 선언된 변수는 값이 없어서 그냥 쓰면 오류가 나겠지만...
	// 우리가 입력으로 값을 넣어줘보자

	std::cin >> input;// c+in : 컴퓨터에게 입력을 하는 기능

	std::cout << std::endl << (input+1) << std::endl;


	//변수 두개 선언하기 int 
	// 값을 바로 할당하지 않고 , 두 변수에 각각 입력을 받아서 값이 할당되게 해주세요
	// 입력 두번 필요
	// 그렇게 받은 두개의 int 변수로 아래 있는 산술 , 비교 연산을 진행해서 출력하시고
	// 그 중에서 사칙연산 결과는 다른 변수로 다시 할당해주세요
	// 해당 변수들에 대한 일치, 불일치 등 논리 연산도 수행해서 출력해주세요
	// 선언 할당 뜻은 문서 내에 있음







}

