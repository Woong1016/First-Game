#include <iostream>

// 포인터 상수, 상수 포인터



// 지난 주 과제 풀이 예시
// * 말씀드리지만 이건 정답이 아닙니다. 여러 답 중 하나일 뿐이죠.
//   다 못하신 분도 오늘의 예시를 참고 삼아 스스로의 선택을 찾으시길 바랍니다.
#include "25703.h"
#include "BubbleSort.h"

int main()
{
    // 백준 25073 "포인터 공부" 실행 예시
    //ExampleCode25703();

    // 거품 정렬 예시
    //ExampleCodeBubbleSort();

    //------------------------------------------------------
    
    /*
    비주얼 스튜디오 앱 사용 팁 :
    이 문단 위아래에 기호를 사용하면 (/ * , * / 각각 붙여쓰기)
    두 기호 사이에 있는 모든 글을 주석으로 만들 수 있습니다.
    */

    //------------------------------------------------------

    // 지난 시간의 복습 (짧고 굵게)

    int a = 10; // 그냥 변수. 누가 말 안 해도 다 아는 그 변수.

    10; // 그냥 상수. 누가 무슨 말을 안 해도 문자 그대로 상수. (리터럴 상수)

    const int aCon = 10; // 원래는 변수처럼 만들었지만 const가 붙어 상수가 된,
                         // 기호에 의한(symbolic) 상수, 혹은 '심볼릭 상수.'
                         // 플밍에서 말하는 '상수'는 대체로 이 심볼릭 상수입니다.
    //-----------------------------------------------------------------------
    
    // 그리고 과제 겸, 오늘의 화제

    // "상수와 포인터를 한 자리에 쓰면 무슨 일이 일어날까?"

    int aVar = 10; // 다시 변수

    int* aPtr = &aVar; // 이건 포인터

    const int* aConPtr = &aVar; // 되네?
    
    int* const aPtrCon = &aVar; // 되네? (이런 게 된다는 말도 못 들었지만!)

    std::cout << *aPtr << std::endl;
    std::cout << *aConPtr << std::endl; // 되네?
    std::cout << *aPtrCon << std::endl; // 되네?

    // 그런데

    int bVar = 200;

    aConPtr = &bVar; // 되는데
    aPtrCon = &bVar; // 외않됌?

    // 포인터 아님?

    *aConPtr = bVar; // 이건 또 외?
    *aPtrCon = bVar; // 또 이건 왜 됨?

    // 왜 안 됨? 머가다름?

    // ----> 에 대한 것을 직접 겪어보셨다면, 훌륭히 오신 겁니다.
    //       오늘은 이 부분을 풀어보겠습니다.

    // 오늘의 진도는 '상수 포인터'와 '포인터 상수'라는 것에 대해서입니다.

    //-----------------------------------------------------------

    // 우선 const의 작성 위치와 의미를 다시 설명

    int n = 1000;

    const int nCI = 10000; // 우리가 알았던 상수

    //그런데

    int const nIC = 10000; // 이것도 사실은 상수
                         // 그런데 왜 안 썼을까?

    // const의 의미가 증감연산자와 비슷하게 작동하기 때문
    // const : 따라오는 데이터를 컴퓨터나 다른 사람이(미래의 나 포함)
    //         함부로 바꾸지 못하게 만드는 기능을 한다

    // const + int : "상수가 있고, 그 상수는 int다"

    // int + const : "int가 있고, 이 int는 상수다" 라는 의미

    // .... 그냥 자료형이 있는 변수일 때는 이 표현의 미묘한 차이가 의미가 없다
    // 하지만, 포인터가 개입하면 미묘한 차이가 실제 의미를 갖는다

    // 왜냐면 포인터도 자료형에 붙어서 새로운 의미를 주는 연산자니까.

    // 그래서 *(포인터 연산자)와 const(상수 지시)가 같이 쓰일 경우
    
    // 둘의 위치 관계에 따라, 상수 포인터, 혹은 포인터 상수라고 다르게 부른다

    // 그리고 진짜 다르다



    // 1. 상수 포인터

    // 기본 표현 : const (자료형)*

    const int* conPtr = &n; // 위에서 만든 n 변수 사용

    // 한국인이 읽는 방법 : 앞에 있는 연산자부터 읽으면 된다 (const -> *)

    // * 상수 포인터의 의미

    // 상수 포인터의 원문 : 'pointer to contant' 중요한 건 사이에 있는 to
    
    // 우리말의 의미는 '상수로 *가는* 포인터'라는 뜻
    // 쉽게 풀면 "원래 상수였든 아니든, 지금부터는 상수처럼 쓰겠다"는 것
    // 무엇을? 이 데이터를. 포인터가 지시하고 있는 대상을.
    // 어떤 사람은 그래서 이 의미를 '상수로 만드는 포인터'라고도 해석한다

    // 그래서 상수 포인터는 다음 용례가 성립한다

    *conPtr = 7; // 포인터가 가리키는 메모리 주소의 데이터는 더 이상 못 고친다
                 // 마치 상수인 것처럼 취급한다

    // 주의점 : 상수 포인터는 "상수인 것처럼 만들기는 하는데"
    //         원본이 상수가 되지는 않는다.

    n = 7; // <- 이건 여전히 잘 된다

    // 그리고 "(대상을) 상수로 만드는 포인터"라는 이름은....
    // ...자기는 아직 상수가 아니라는 뜻도 된다.

    // 역참조 대상인 실제 데이터는 못 고치는 대신, 포인터의 지칭 대상은 수정 가능

    conPtr = &bVar; // 상수 포인터가 지칭했던 대상을 n에서 bVar로 바꾸는 건 된다

    // 다시 요약

    int x = 0;
    const int* xCP = &x; // 상수 포인터

    *xCP = 1; // 상수 포인터는 역참조 값(실제 데이터) 수정 불가능

    xCP = &n; // 상수 포인터는 포인터의 대상(참조할 대상) 수정 가능

    // 결론 : 상수 포인터는, 참조된 "데이터"를 *상수로 만드는 포인터*



    // 포인터 상수

    // 위에서 말한, 다른 쪽 '상수 포인터'...의 반대라고 보면 OK

    // 정확히 말하면, 이쪽의 원문은 'constant pointer'

    // 우리 말로는 '포인터의 모양을 한 상수'라는 뜻


    // 기본 형태 : (자료형)* const
    //            = 포인터 변수가, 지금부터, 상수다.

    int* const ptrCon = &n; // 포인터 상수

    // 포인터 상수의 용례

    *ptrCon = 7788;         // 역참조의 대상은 수정 가능
                            // 왜? 포인터가 상수지, 이 메모리 위치가 상수는 x

    ptrCon = &bVar;   // "포인터로서 참조해야 할 대상"은 이제 수정 불가능
                      // 왜? ptrCon이라는 이름의 "이 포인터 변수"가 바로 상수라서

    // 따라서 내부의 데이터는 고칠 수 있지만, 참조해야 할 대상은 무조건
    // 처음에 정해진 대로만 가야 되는, 그런 포인터 + 상수 조합이 포인터 상수



    // 상수 포인터, 포인터 상수의 중요성 (혹은 용도)

    // 상수 포인터는 언제 쓰는가?
    
    // 개발자 입장에서 원래 데이터는 어느 정도 수정할 수 있게 하고 싶은데
    // 개발자 외에 다른 사람이 해당 데이터를 함부로 못 고치게 하고 싶을 때

    // 그럴 때 상수 포인터를 쓸 수 있다

    // 예 : 채팅 로그 파일의 이름, 플레이어 이름 같은 것

    // 그때 이런 식으로 상수 포인터를 쓸 수 있다

    char word = 'a'; // c++에서 자유롭게 쓸 수 있는 '문자 집합'은 나중에 나오므로
                     // 지금은 이 문자를 '이름'으로 간주

    // 아무튼 이 데이터를 준비해서, 나중에 쓸 수 있게 하되...

    const char* wordCP = &word; // 외부에는 이렇게 지칭을 시켜준다
                                // 그러면 외부에서는 wordCP를 못 고친다

    *wordCP = "헬로, 월드!"; // <- 이거 안 됨

    // * c++의 경우, char는 특수한 취급이어서 포인터+배열 관점에서도 수정이 안 된다
    //   다만 나중에 문자열 기능을 접하면, 그 때도 이 상수 포인터가 적용된다

    // 더불어서 상수 포인터를 쓰는 다른 이유도 있다

    // 특수한 경우지만... 쓸 때는 상수로 되는 변수가 있는데
    // 만들 때는 미리 값을 지정할 수 없는 경우가 있다

    // -> 상수는 이게 허용이 안 된다 (선언과 동시에 값이 있어야만 한다)

    const int id; // <- 이거 안 됨

    // 그래서 일단 변수부터 만들고 나중에 값을 주되, 그래도 상수인 것처럼 쓰려고
    // 할 때, 그 때 상수 포인터를 활용할 수 있다

    int var000; // 이상한 이름을 가진 실질 데이터를 만들어 숨기고
    const int* ID = &var000;// 외부에는 이 데이터만 보여준다

    // 위의 'id'처럼 미리 ID 데이터를 자리만 만들어두고, 값은 나중에 주고,
    // 이 데이터를 일종의 상수로(고칠 수 없게) 만들려고 할 때 상수 포인터를 활용한다

    // * 물론 var000 같은 본래 데이터가 들통나면 위험은 하지만...
    //   아예 무방비한 것보다는 조금 낫다


    //-------------------------------------------

    // 포인터 상수는 그럼 언제, 왜 쓰는가?

    // 데이터가 일단 어딘가에 저장되면 ( 어떤 연산이 처음 이루어지면)
    // 해당 데이터가 처음부터 끝까지 계속 쓰여야 하는 경우가 있다

    // 그리고 해당 데이터 위치의 값은, 실제 데이터는 바뀌더라도
    // 그 위치 자체는 절대 바뀌면 안 되는 경우가 있다

    // 가장 대표적인 것 : 온라인 게임의 플레이어 데이터

    // 이렇게 참조의 일관성을 유지해야 할 때, 포인터 상수를 사용한다.

    //---------------------------------------------

    // (짜투리 지식) 상수와 포인터가 합칠 수 있듯이...

    // 상수 포인터와 포인터 상수도 또 합칠 수가 있다!

    // 이것을 "상수 포인터 상수"라고 한다.

    const int* const xConPtrCon = &aVar; // const + 자료형 + * + const

    // 용례...라기보다 그냥 안 되는 것을 확인

    xConPtrCon = &bVar; // 참조 수정 못함 (포인터 변수가 그 자체로 상수)
    *xConPtrCon = 10000000; // 역참조 대상 수정 못함 (실제 데이터도 상수처럼)

    aVar = 999; // 물론 원본은 아직 상수 아님

    // -> 포인터 변수에 극한의 구속을 주고 싶을 때 (참조 대상도, 실질 데이터도)
    //    그 때, 이렇게 앞뒤로 전부 const를 지시할 수 있다.

    // 이게 상수 포인터 상수

}