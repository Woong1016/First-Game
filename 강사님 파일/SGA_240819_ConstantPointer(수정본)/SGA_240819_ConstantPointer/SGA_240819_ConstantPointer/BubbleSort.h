#pragma once

#include <stdlib.h>
#include <Windows.h>

void ShuffleArray(int target[10]);
void ShowArray(int target[10]);

void ExampleCodeBubbleSort()
{
    srand(GetTickCount64());

    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    ShowArray(arr); // 섞기 전의 배열 출력

    ShuffleArray(arr); // 섞기

    ShowArray(arr); // 섞은 다음의 배열 출력

    // 지금부터 정렬을 시작합니다

    for (int i = 0; i < 10; ++i) // 10개에 대해 10번 비교한다는 뜻
    {
        //for (int j = 0; j < (10 - 1); ++j) // 이쪽이 진짜 비교할 대상
        // -> 이 반복문은 중복에 대한 고려가 없다
        // -> 만약 1차 반복이 끝났으면 이미 맨 오른쪽에 제일 큰 숫자가 있을 테니
        //    반복문에서 빼도 된다.
        
        //    따라서, j가 가야 할 마지막 반복 차례가 0순번일 때는 8인데
        //    1순번이면 7, 2순번이면 6... 이렇게 줄어든다

        // 해당 의미를 반복문의 조건에 추가하면 아래처럼 된다

        for (int j = 0; j < (10 - 1 - i); ++j) // "이전에 수행한 반복문 차례"
                                               // 를 빼는 걸 반영 ( - i)
        {
            // 1. 매 차례 가장 왼쪽에 있는 원소부터 검사해서
            // 2. 해당 차례 가장 왼쪽이었던 원소의 '제자리'를 찾아준다

            // 왜 j < 9 가 아니라 j < 10 - 1 인가? 그게 그건데?
            // 연산상으론 똑같다. 중요한 건 의미 표현의 문제.
            // 같은 조건이라도 j < (10 - 1) 이렇게 적으면
            // "원래는 10개를 비교하는데, 마지막 직전과 마지막까지 비교한다"
            // ...라는 말을 간접적으로 나타낼 수가 있게 된다
            
            if (arr[j] > arr[j + 1]) // 0순번이면 1순번과, 1은 2와... 쭉 비교
            {
                // 조건이 맞으면 자리 바꾸기
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
            // 오른쪽이 더 크면 그냥 그대로

            // (옵션) 정렬을 1차례 할 때마다 중간 결과를 출력해서 확인합니다.
            ShowArray(arr); // * 함수를 미리 만드는 게 이렇게 편합니다.
                            // 매번 코드 짤 필요없이 준비해둔 이름만 부르면 끝
        }

        // 총 10개의 원소에 대해, 오른쪽과의 비교를 끝내고 나면
        // 반드시, 무조건, 어떻게든 정렬은 끝날 수밖에 없습니다.

        // 그러나 거품 정렬의 경우, 다른 반복에 의한 계산의 누적... 다시 말해
        // 다른 수렴 계산과 마찬가지로 중복이 일어나는 경우의 수가 생깁니다.
        // 이 수를 연산에서 빼주지 않으면 무의미한 연산이 계속 반복되죠.

        // (예 : 이미 제 자리를 잡은 오른쪽의 '큰 수'들끼리 또 비교하는 것)

        // 그래서 이런 연산의 중복을 피하기 위해 반복이 이루어질 때마다
        // 계산의 범위를 1씩 줄여나가줘야 합니다.

        // 결과적으로 처음에 10번, 마지막에 1번 비교를 하는
        // 내림차 계산이 됩니다.

        // 따라서, 거품 정렬의 원칙상 총 계산 횟수는 n(n - 1)이지만,
        // 실제 정의 혹은 수학적 총 계산 횟수는 n(n - 1) / 2 입니다.

        // 그리고 여기서 말하는 "수학 혹은 정의에 의한 총 계산 횟수" 더 나아가
        // 이 알고리즘을 컴퓨터가 실행하면 최대 몇 번까지 계산할 것 같은지...
        
        // ...를 "시간 복잡도"라고 부릅니다.
    }

    //정렬이 끝난 배열 출력
    ShowArray(arr);

    // 실행이... 잘 될까요? 되겠죠? ㅎㅎ...
}

void ShuffleArray(int target[10])
{
    for (int i = 0; i < 1000; ++i)
    {
        int randA = rand() % 10;
        int randB = rand() % 10;

        int tmp = target[randA];
        target[randA] = target[randB];
        target[randB] = tmp;
    }

    // 배열의 이름은 곧 포인터.
    // 그러므로 이 경우는 매개변수를 직접 바꿔줘도 됩니다.
    // 배열이 아니었다면, 매개변수를 포인터로 선언해주면 됩니다.
}

void ShowArray(int target[10])
{
    for (int i = 0; i < 10; ++i)
    {
        std::cout << target[i];
        if (i < (10 - 1)) std::cout << "  ";
    }
    std::cout << std::endl;
    std::cout << "----------------------" << std::endl;
}