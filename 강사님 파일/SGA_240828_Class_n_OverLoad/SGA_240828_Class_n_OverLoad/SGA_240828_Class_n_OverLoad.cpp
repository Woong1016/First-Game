// SGA_240828_Class_n_OverLoad.cpp

#include <iostream>
#include "UseSampleCharacter.h" // 과제풀이 : 샘플 캐릭터 써 보기

//----------------------------------------------------------

#include "MyCharacter.h" // 오늘의 강의를 위한 교본 클래스

int main()
{
    // 과제풀이 실행
    UseSampleCharacter* homework = new UseSampleCharacter();
                                   // 생성과 동시에 생성자 실행
    homework->PrintCharacters();   // 캐릭터 출력

    //------------------------------------------------------

    // 오늘의 진도 : 생성자와 같이 다니는 반대 개념 및
    //              생성자 응용, 그리고 함수 자체의 심화 활용

    // -> 진행이 위에서 include한 교본 클래스와 같이 가므로 같이 봐주세요.

    // * 클래스의 소멸자에 대해
    //   : 교본 캐릭터 클래스에서 소멸자를 보고 돌아오기

    MyCharacter* myCharacter1 = new MyCharacter();

    myCharacter1->Set(111, 222); // 적당히 스테이터스를 넣고
    
    myCharacter1->ShowMe();      // 출력

    // 여기서 이 객체를 다 썼으니 이제 지운다고 가정을 해보자

    // 그럼 어떻게 이 객체를 지우느냐?

    //myCharacter1->~MyCharacter(); // 이러면 코드 안에선 오류가 안 나지만...
                                    // *틀린 사용이다. (이렇게 쓰지 말 것)

    // 객체 (정확히는 인스턴스의 포인터) 지우는 법

    delete myCharacter1;    // delete 포인터명 : 메모리 주소 삭제

    // -> 위 코드를 실행하면 1. 포인터 등록이 삭제되면서
    //    2. 포인터 위치에 있던 인스턴스의 소멸자 함수도 같이 실행된다

    // -> 정확히는 'myCharacter1'이라는 이름으로 등록했던 메모리 주소가
    //    데이터에 대한 점유권, 혹은 앱 내에서의 연산 보장권을 잃고
    //    주인 없는 위치로 남게 되는 것

    //    : 데이터는 그 자리에 계속 남기는 하겠지만....
    //      이후에 어떤 이유로든 그 자리에 새로운 데이터를 덮어씌우면
    //      컴퓨터는 그냥 해당 위치를 써버릴 것.

    //    이상의 설명은 이론적인 부분도 있으므로, 이해가 힘들다면 그냥
    //    delete 포인터명 = 삭제라고 생각해도 OK

    // 한번 더 확인

    MyCharacter* myCharacter2 = new MyCharacter(); // 만들 때는 이렇게

    delete myCharacter2; // 지울 때는 이렇게


    // * 지워진 다음에 해당 위치에 있던 데이터를 써도 될까?

    myCharacter1->ShowMe(); // 코딩에 오류 표시가 없다 (경고는 있지만.)

    // 하지만 실행을 해서 확인해보면 알 수 있듯
    // 객체를 지운 시점에서 컴퓨터는 해당 메모리를 "막 써도 되는 곳"으로 이해한다
    // 그리고 운이 좋다면 (혹은 컴퓨터 사양이 충분하지 않다면) 그 막 써도 되는 곳에
    // 컴퓨터가 진짜로 새로운 데이터를 덮어씌우게 되고
    // 출력 시에 내가 입력하지 않았던 다른 데이터가 출력되는 것을 볼 수 있다

    // -> 한 번 지우면 해당 객체는 정말 없다고 생각하고 안 쓰는 게 최선

    // -> 더 좋은 방법은.... 지금은 아니지만 장차 객체를 더 다양하게 쓸 경우
    //    해당 객체를 안 쓰겠다 싶은 시점에서 그냥 칼같이 지우는 거.
    
    //    (지금 당장은 신경 x 미래에 실전에 들어갈 때 익숙해지기 위한 언급)

    // ----------------------------------------------------------------

    // 여기까지가 소멸자

    // 그런데... 소멸자의 형태가 조금 신경쓰이는 부분이 있다

    // 변수도, 함수도, 이름을 중복하면 절대로 안 된다고 했는데
    // 소멸자는 어째 ~ 연산자 빼고 나면 이름이 생성자와 똑같지 않나?

    // -> 왜 됨?

    // 되는 이유 : C++에서 "함수의 이름이 어디부터 어디까지냐"가
    //            단순한 이름의 철자만을 두고 따지는 게 아니라서

    // C++에서 말하는 "변수"의 이름 : 이름 철자만

    // C++에서 말하는 "함수"의 이름 : 이름 철자
    //                              + * 이외의 연산자들
    //                              + 매개변수까지
    //                              이 모두가 함수의 이름에 포함된다

    // -> 따라서 같은 철자라도 앞에 소멸 연산자를 붙인 소멸자는
    //    생성자와 이름이 다른 걸로 쳐준다

    // -> 그리고...같은 이름 철자인데, 매개변수가 달랐다면
    
    //    그것 또한 C++에선 별개의 이름을 가진 함수로 쳐준다

    // -> 해당 함수 이름 범위에 대한 판정을 MyCharacter에서 확인해보기

    MyCharacter* myCharacter3 = new MyCharacter();

    //myCharacter3->Set(123, 456); // 처음 만든 int, int 함수

    float f1 = 10.8f;
    float f2 = 0.3f;
    //myCharacter3->Set((f1+f2), (f1*f2)); // 소수가 들어가면 int 함수로는 못 쓰니까
                                         // 대신 float 함수인 것처럼 컴퓨터가 이해
    //myCharacter3->Set(12345678); // int를 하나만 쓴 함수
    myCharacter3->Set();         // 매개변수 안 넣기
    
    // 위의 함수 4종류를 각각 주석에서 풀어서 실행한 후 결과를 출력

    myCharacter3->ShowMe(); // 오류 없이, 의도대로 출력

    // -> c++에서 말하는 함수의 이름은 철자만이 아니라 앞뒤 연산자, 그리고
    //    따라오는 매개변수의 개수, 자료형까지도 포함한다는 것을 확인
    
    // -> "그러면 매개변수의 철자는요?"
    //    철자는 달라도 컴퓨터가 인지하지 않는다 (이쪽에서 중복 내기 쉬워서 주의)

    // 이렇게 컴퓨터가 함수의 이름을 어떻게 인지하는지를 활용해서

    // 사용자 입장에서는 함수 개발을 편하게 할 수 있다

    // "같은 이름에, A 경우에는 어떤 매개변수 쓸지, B 경우는 또 어떻게 쓸지"
    // 경우의 수를 나눠서 각각의 다른 함수를 만들 수 있으므로

    // -그리고 이렇게 인간 입장에서 이름이 비슷한 (함수명의 철자가 같은)
    //  그러나 컴퓨터 입장에서는 구분이 가능한 (실제 함수명은 서로 다른)

    // 이런 함수를 작성하는 행동, 혹은....
    // 이렇게 만들어진 함수들을 지칭해서 "함수 중첩(overload, 과적)"

    // 혹은 발음 그대로 "함수 오버로드"라고 한다

    // -------------------------------------------------------

    // 함수 중첩의 응용 : 생성자의 중첩
    
    // MyCharacter 클래스에 생성자 오버로드를 하고 호출

    MyCharacter* myCharacter4 = new MyCharacter(9876, 54321);
                                // 생성과 동시에 생성자 속에 값 넣기

    // Set 실행 없이 출력
    myCharacter4->ShowMe();

    // -> 실행이 된다

    // -> 함수 오버로드는 "컴퓨터가 함수 이름을 어떻게 보느냐"에 대한 문제
    //   = 생성자에도 똑같이 적용된다

    // 클래스에 따라 생성자 오버로드가 꼭 필요한 건 아니다 (안 그런 경우도 많다)
    // 하지만 그래도 적절한 곳에 잘 쓰면 사용자가 매우 편하다

    // + 그리고 경우에 따라, 생성자 오버로드가 반드시 필요한 경우도
    //   가끔 있다

    // -> 멤버 이니셜라이저 : MyCharacter 클래스에서 작성 및 확인

    //이니셜라이저 호출을 통한 인스턴스 생성 사례

    MyCharacter* myCharacter5 = new MyCharacter(1, 2345, 67890);
                                // id를 외부에서 설정 가능한
                                // 숫자 세 개짜리 생성자 실행
                                // -> 작성할 때는 이니셜라이저로 다르게 썼지만
                                // 불러올 때는 그냥 평범하게 불러도 된다

    myCharacter5->ShowMe(true); // bool 데이터를 써서 id까지 출력

    // ------------------------------------------------

    // 여기까지 멤버 이니셜라이저

    // 멤버 이니셜라이저 : 생성자의 () {} 표시 사이에 적어서
    // 멤버 변수의 초기값을 {} 실행 전에 미리 확정해주는 것.

    // 클래스 내에 {} 안에서 수정할 수 없는 데이터가 있거나
    // (상수, 보안상 비공개 데이터 등)

    // 여러 클래스를 쓸 때 미리 데이터가 준비되어 있어야 한다거나 (실행 시점 빠름)

    // 혹은 단순히 컴퓨터 성능의 향상을 노릴 때도 (실행 속도 빠름)

    // 유용한 코딩 방법이므로 꼭 익숙해질 것

    // -------------------------------------------------

    // 짜투리 이야기 : 매번 이니셜라이저가 무조건 좋은가?

    // 사실 그건 아니다. 멤버 이니셜라이저는 컴퓨터 입장에서 '효율적'이다.
    // 그런데 컴퓨터에게 효율적이라는 게 무조건 적절한 코딩은 아니다.

    // 예 : 다른 클래스보다 오히려 늦게 만들어져야 하는 데이터가 있다면?
    //      -> 온라인의 랜덤 퀘스트 생성 등 (등장인물 등의 데이터가 있어야 하니까)

    // 혹은 단순히 코딩의 의미를 명확히 해두기 위해서라도
    // (int a의 값은 처음에 n이라고 정한다고 치면, 이니셜라이저 속 a(n)보다
    //  결국 a = n; 이라고 제대로 적어주는 편이 나중에 읽기 편하다! 사람이.)

    // 경우에 따라서는 다시 보통의 코딩으로 생성자를 만들기도 한다.

    // 더구나 멤버 이니셜라이저가 할당해주는 대상은 오직 그 클래스의 멤버뿐.
    // = 다른 클래스의 데이터까지 다루겠다면 (예 : 오늘의 과제풀이 클래스라든가)

    // 그럴 때는 그냥 평범하게 코딩하는 게 맞기도 하다.
}