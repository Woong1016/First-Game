// SGA_240913_Processor_n_Template.cpp

#include <iostream>
#include "Homework.h"

// 연휴의 과제 1: 템플릿 복습
// 
// 사칙연산을 템플릿으로 한번 더 작성해주세요
// 그리고 main이나 다른 곳에서 int , float , double로 출력해봅시다.
// 
// 연휴 과제 2: c++ 기본 기능을 사용해서 만들 수 있는 ....
//				간단한 게임들(예: 방고, 카드게임, 텍스트 게임) 
//				난 텍스트 방탈출 만들거임
//				그것들을 우리가 다음주에 과제 대신 도전해보자
// 
//				그러므로 이번 주에는 내가 어떤 게임을 만들어볼지
//				한번 구상을 해주세요(컨셉, 따라할 대상, 필욯ㄴ 기능...)
// 
//			* 위에 든 예시 말고도 콘솔 환경에서 의외로 여러 게임을 만들 수 있습니다.
//			실제로 만들어진 게임의 사례 : 그래픽 없는 포켓몬
//										그래픽만 없는 실시간 액션...
// 
#include "template.h"
#include <string>
int main()
{
	//과제


    // 과제풀이--------------------------
    //Homework* hw = new Homework();
    //hw->Run();
    //----------------------------------

	//오늘의 진도 

	// 벡터 , 리스트, 맵 등을 선언할 때, <>를 써서 자료형을 지정해야 했다.
	//=> 이게뭘까?

	//=> 이 부분을 살펴보려면 다시 두가지를 살펴바야 한다.
	// 1. 정의 지시 
	// 2. 정의 지시 중'template' 이라는 기능

	// 1. 정의 지시: 데이터의 정의를 사용자가 지시하는 것.

	// 예: int는 숫자다. int라고 적으면, 컴퓨터는 숫자라고 이해한다. 

	//=> c++에는 기본적인 자료형, 함수등은 정의가 이미 존재한다.

	//=> 하지만 , 일부 정의는 사용자가 추가로 지시할 수 있다.

	//그 중에서도 대표적으로 쓰이는 두 정의 지시가 둘 이싿.

	//하나는 typedef 자료형 정의하기 다른하나는 template ' 도식화 ' 이다

	// =============================================

	//1. typedef : 정식 용어는 "자료형 재정의" 

	// -> 원래는 자료형을 정의하는 용도로 사용하는데, 그 밖에 
	// 이미 이름이 존재하거나, 정의가 끝난 데이터에도 사용할 수 있어서 '재'정의

	//--> 쓰는 입장에서 이해하자면 "데이터에 이름 붙이기" 라고 이해하면 편하다

	// 사용 예시
	typedef int SUTJA; // int 즉 숫자 자료형에 숫자라는 이름을 붙인다

	int a = 0;	// 숫자 데이터 만들기
	SUTJA b = 1;	// 숫자 데이터지만 , int가 아닌 sutja라는 이름으로 사용
	//다시 말해서, ㅣ 하뭇 안에서는 int = SUTJA
	//* 전역변수 자리에 typedef가 쓰인다면, 어디서나 int = SUTJA가 된다

	std::cout << b << std::endl;


	//사용의 또 다른 예시

	typedef long long int BIG ; // long ling int 자료형을 BIG로 지칭

	BIG big = 99999999;

	std::cout << big << std::endl;

	//이렇게 긴 자료형을 짧은 이름으로 줄여서 쓰기도 편하다

	//사용의 또또 다른 예시

	typedef struct {
		int x;
		int y;
	} GUJOCHE;

	//=> struct 지시후, 이름이 없는 , {}로 내용만 있는 임의의 데이터를 만든 후
	//(우리가 만들었으므로 이름이 있을 수없는) 이데이터에 새 이름을 붙인 것
	// -> 이름이 없는 임의의 데이터를 스스로 정의한 것

	//	*struct GUJOCHE {}; 이렇게 구조체를 만드는 것과 똑같다.

	GUJOCHE strct;
	strct.x = 100;
	strct.y = 1000;

	std::cout << strct.x << std::endl;
	std::cout << strct.y << std::endl;

	// 이렇게 자료형 재정의를 하면 한번 작성한 내용을 가지고 계속 다른이름으로 쓰거나
	// 예시:
	typedef GUJOCHE GG; // 이미 정의된 자료형에 또 이름 붙이기 (재활용)

	//... 아니면 아주 아주 긴 자료형을 쓰기가 너무 귀찮을 떄

	typedef unsigned long long int XX; // * unsigned 는 음수 양수 구분 없는 자료형
									// 너무 긴 자료형을 일일이 타자칠 필요 X

	//혹은 나중에 컴퓨터 안에서는 구분이 되지만 , 쓰는 사람 입장에서 애매한 이름을
	// 좀 더 직관적인 이름으로 고쳐 부를 때 등의.. 상황에서 편하게 코딩할 수 있다.

	//-------------------------------------------------------------------

	// 1-1. "정의 지시의 처리(process)와 처리 과정(processor)

	//		그리고 전처리기

	//이렇게 사용자가 컴퓨터에게 내린 지시는 각각 특정 시점에서 처리가 된다.
	//보통은 일반 코드와 같은 순서로 코드가 적힌 위치에서 수행되고...

	//두가지 예외가 있다.

	// 하나, 전역변수 자리에 있는 경우. 이 경우, 다른 함수 등보다 더 우선적 순위
	//   (파일은 같은 자리에 잇어야 한다.)


	// 둘 , 지시 앞에 '#' 연산자가 있는 경우 : 이 경우는 특히 두드러진다.
	//		이 경우 , 아예 처리 시점이 앱 실행이 아니다 -> 빌드 시점에서 처리
	//		그래서 같은 이름이지만 (processor) 한국에서는 이 과정을 따로 분리해서
	//		지칭하기도 한다. 바로 ... "전처리기" (처리기processor + 전)

	// 전처리기는 코드 앞이나 중간에 #을 끼워서 지시를 내린다.
	// 그러면 앱 실행이 아닌 아예 파일이 생성될 때 , 컴퓨터가 그에 맞는 수행을 한다.
	//대표적으로 우리가 다뤄본 #include (기능 포함하기) #pragma(뒤 이은 명령어 처리)
	//#define , #if .... 같은 기능이 있다. 다음 기회에 상세히 알아봅시다.

	// ----------------------------------------------------

	// 2.template 정의 및 지시

	//-> 사용자가 임의로 지정한 자료형을 기준으로 하여 작성된 코드 도면

	//-> template.h 헤더 파일에서 상세 작성 및 설명 후, 여기서 사용

	//------------------------------------------------------------

	//헤더에서 만든 Print 함수 써보기

	int num = 10;
	float rnum = 10.111f;	// 소수는 뒤에 f붙일 것

	//print(num);// 될 것 같지만 안된다 만약 된다면 다른 함수가 실행되는 것

	// 템플릿 함수 쓰는 방법

	Print<int>(num); // 함수 이름 뒤에 , () 앞에 <> 를 넣어서 무엇의 함수인지 지정

	Print <float>(rnum); // 소수

	//<>에서 사용자가 자료형을 제대로 지정해야 되는 이유
	
	Print<int>(rnum); // 매개변수에는 소수를 넣지만 , 함수 실행 중 <> 지정은 정수
						// -> 소수가 들어가도 정수 함수로 지칭되면 (<int>라면)
						// 매개변수는실제로는정수처럼취급된다

	//이렇게 template으로 작성 후 , 호출에 <>를 통해 자료형을 지정하면
	// 같은 함수 코드를 쓰는데 그때 그때 다른 자료형에 맞추어서 실행할 수가 있다
	// 실행할때마다 자료형이 자주 달라져야 되는 함수가 있거나
	// 클래스가 있는데 어떤 자료형이 기준일지 작성 시점에서 감도 안잡힐때
	//템플릿으로 작성하면 호출할 때 편하다

	//템플릿의 예: std::vector , std::list , std::map///

	//			무엇의 배열인가> 무엇의 자료 구조인가> 코딩할 때마다 다르니까.
	// -> map은 <>안에 들어가는 자료형이 두갠데? 그래도 되나?
	// 된다. (헤더에서 복수 자료형 템플릿작성)

	//헤더에서 만든 Add 함수 사용

	int result_i;
	float result_f;
	double result_d;

	result_i = Add<int, int, int>(10, 3);
	result_f = Add<float, float, float>(10.111f, 3.3333f);
	result_d = Add<double, double, double>(10.111111, 3.33333);


	
	std::cout << result_i << std::endl;
	std::cout << result_f << std::endl;
	std::cout << result_d << std::endl;

	//* 확인해봅시다: 위 Add 함수의 <> 속 자료형을 각각 바꾸면서 시험해봅시다.
	

	//예
	/*result_i = Add<int, int, int>(10, 3);
	result_f = Add<float, float, float>(10.111f, 3.3333f);
	result_d = Add<float, float, float>(10.111111, 3.33333);*/
	// 자료형을 바꾸는 것만으로도 변화가 생긴다. 연산의 문제 및 자료형의 변환 오류

	//* 확인해봅시다: print로 문자를 출력하면?

	//혹은	<>안에 출력의 대상이 될 수 없는 자료형이 들어간다면?

	//예시

	Print<std::string>("안녕하세요 컴퓨터입니다");

	//======================================================

	//템플릿 클래스 써보기

	
}