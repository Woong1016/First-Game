#pragma once
#include <iostream>


// 템플릿에 대해

//일반적으로 함수를 작성하거나 실행하면 (구조체 , 클래스 포함)

// 어디에 어떤 자료형을 지정해야 하는지 구체적으로 , 정확히 적어야 한다,

// 예 
int Hamsu() { return 0; }; // 자료형으로 'int' 정확히 지정해야함

//-> 그리고 이렇게 정확히 지정한 자료형에 의해서 함수가 실행되면
//	반드시 그 자료형에 맞는 데이터만이 반환된다.

//자료형이 만약 다르게 쓰여야 되는 경우 , 함수 오버로드로 같은 함수를 여러번 작성

//그런데 모든 함수를 모든 경우의 수에 대응하려면 의외로 귀찮다.

//그리고 만약 c++에 원래는 없었던 자료형을 서야 한다면?

//: typedef 지시를 통해 새롭게 만들거나, 이미 있던 자료형이지만 이름을 바꿨거나
//이런 경우에도 함수가 모두 대응해줘야 한다면??

//C++의 해결책 : 아예 자료형이 뭔지 무조건 정하기보다,
// 특정한 자료형을 사용할 수 있다" 고 일부러 빈 칸을 지정해주고
//해당 빈 칸과 가명을 사용해서 논리 구조만을 작성하는 함수를 만들자

//예: "정수와 정수를 더하는 덧셈함수"를 만드는 대신...
//  "데이터 X와 데이터 Y를 더하는 다목적 덧셈 함수"를 만들자!
//	나중에 이 다목적 덧셈 함수를 부를 때, 그 때 추가로 부연설명을 붙여서
//	데이터 X는 정수고, 데이터Y는 소수다 .... 하는 식으로 부른 쪽이 지정하는
//	일종의 (비유하자면 ) 착불 함수를 만들자!

//이것이 템플릿의 개념.

//---------------------------------------------------------------

//템플릿 코드로 써보기 

//사용 예시

template <typename T> // 템플릿 정의 지시
					  // 
void Print(T data)		// T라는 이름으로 매개변수 지정
{
	std::cout << data << std::endl;	// data 출력

	
	
}
// 첫 줄 template <typenameT> : 템플릿을 선언하는 줄
//	template : 이 다음에 작성하는 코드는 템플릿으로 친다는 뜻 (정의 및 지시)
// <> : 이 안에 작성하는 코드는 템플릿의 규칙이라는 뜻(선언의 의미)
//		나중에 템플릿 코드를 호출할 떄 쓰면 <> 는 해당 규칙의 값을 지정한다는 뜻
//		(포인터 연산자와 비슷하다. 변수 선언에 쓰이면 주소, 호출에 쓰이면 참조)

//<>안의 typename: 이 템플릿에서 미지의 자료형을 임의로 쓸 수 있다는 뜻
//					나중에 템플릿을 호출 할 때 , 이 자료형이 무엇인지
//					호출하는 사람이 정확히 지정을 해줘야 한다는 뜻

//<>에서 typename 다음의 T: 이 미지의 자료형을 코드 안에서 임시로 지칭한 가명.
//							코드 안에서 T라고 다시 부르면 (여기선 매개변수)
//							해당 T라는 글자를 typename의 대상 즉
//							미지의 자료형인 것으로 치겠다는 뜻

//이렇게 만든 Print를 main에서 호출


//------------------------------------------------------------


//복수 자료형 템플릿

template <typename T1 , typename T2, typename T3> // 여러자료형은 마찬가지로 , 구분
													// 자료형 지칭은마음대로 (T1-T2)

T1 Add(T2 x, T3 y) // 반환형은 T1 , 매개변수는 T2와 T3

{
	return x + y; // 매개변수 둘을 더해서 그대로 반환
}


//------------------------------------------------------------


//템플릿의 응용 (실제 사용은 약간 도식화된 경향도 있음)

//* 템플릿이 사용된 클래스 

template <typename T>	// 템플릿으로 지시된
		
class Test1				//템플릿 클래스
{

public : 

};