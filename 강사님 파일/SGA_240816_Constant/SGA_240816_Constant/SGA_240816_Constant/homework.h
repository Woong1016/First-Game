#pragma once

// 실습과 과제

// 이번에는 과제 4가지를 하나씩 수행해주세요.
// 수가 많은 대신 각 과제 하나하나는 쉽습니다. 진짜예요!

// 부담 없이 도전해보세요.

// 1. const 직접 써보기
// 2. const와 * 연산자 같이 써보기
// 3. https://www.acmicpc.net/problem/25703 링크 문제 풀어보기
// 4. '거품 정렬' 구현해보기


// -- 과제 상세 설명


// 1. const 직접 써보기

// 두 개 이상의 int와, 두 개 이상의 const int를 만들어주세요.

// int끼리, const int끼리, 혹은 int와 const int를 같이 사용하는

// 사칙 연산을 만들어주세요. 함수여도 되고, main에 적으셔도 됩니다. 

// const char* 변수도 만들어보신 후, 한번 출력해봅시다.
// 문자 배열도 만들어보고, 출력해봅시다.

// 중요한 건, 간단한 것일수록 직접 써보고 되는 걸 확인해보는 겁니다.


//---------------------------------------------------------------


// 2. const와 * 연산자를 같이 써보기

// 오늘 우리는 '포인터에 이어' 상수를 알아보았습니다.

// 생각하면 이상한 표현이죠. 이 둘이 목적상의 구분이야 되겠습니다만,
// 얼핏 봐선 딱히 무슨 연관이 있는 것 같지는 않거든요. 문자 빼면, 아직.

// ......그렇죠?

// 확인해보기 위해 아래 코드를 한번 직접 main() 안에 적어주세요.

// A. int a = 0; 이라는 변수를 생성
// B. int* aPtr = &a; 변수도 생성

// C. const int* aCP; 라고 적어보기
// D. int* const aPC; 라고 적어보기
// 
// E. aCP, aPC를 선언한 줄에 각각 값을 넣어 할당해보기
//    (예 : const int* aCP = &a;)
// F. 할당된 값을 다시 불러 바꿔보기
// G. 만들어진 '상수와 포인터를 같이 쓴 변수'를 역참조해보기
// H. 역참조한 코드를 다시 바꿔 보기
//    (예 : *aCP = 100;)

// -> A부터 H까지를 작성한 후, 작성된 화면을 찍어서 카페에 올려주세요.

// 미리 말씀드리자면, 오류가 날 겁니다. 그래도 만들어보세요 ㅎㅎ
// -> 왜 오류가 나는지, 지금 우리가 작성한 게 뭔지... 다음 주에 설명 드리겠습니다.

//    물론 예습을 해보셔도 됩니다. 단, 언제나 복습을 먼저 다 하고 해주세요.

//    지금은 "그냥 따라 해보니까 안 되는데요?" 정도면 충분합니다.
//    그 안 됐더라는 경험이 무엇보다도 중요합니다.


// ---------------------------------------------------


// 3. https://https://www.acmicpc.net/problem/25703 링크 문제 풀어보기

// 박진웅 아이디 : Woong_1016

// 이 사이트는 "백준"이라는 이름의, 코딩 테스트 허브 중 하나입니다.
// 문제를 제시하면, 코드로 요구받은 결과를 만들어내는 방법을 제출하는 곳이죠.

// 비슷한 구조의 사이트 중 한국에서 가장 인기 있는 곳이기도 합니다.

// 이 백준 사이트에 가입한 다음, 링크에 있는 문제를 풀어봅시다.

// 의외로 별거 없어요. 복습하기 좋은 문제입니다.

// 더불어서, 백준이라는 이 사이트도 나중에 여러분이
// 꾸준히 들어와 주면 좋은 곳이기도 합니다.

// 계속 방문하시면서 코딩 테스트라는 개념에 친숙해집시다.

// 이후 여러분이 IT에 개발자로 취업을 하시게 되면
// 요즘은 입사 과정에 이런 코딩 테스트가 빈번히 나오기도 하거든요.


//----------------------------------------------------------

// 4. '거품 정렬' 구현해보기

// '거품 정렬'이라는 알고리즘이 있습니다.
// 이름처럼 무작위 나열된 배열을 정렬하는 데 쓰이는 논리구조 중 하나입니다.

// 이번 과제는 해당 코드를... 100% 자력 구현은 아니고,
// 아래에 드리는 설명을 통해 이해한 후 코드로 바꾸어주세요.

// 알고리즘 소개와 더불어, "설명된 알고리즘을 코드로 바꾸는"
// 코드화 작업을 거품 정렬을 통해 같이 겪어보고자 합니다.


// A. 10개 이상의 정수 원소를 가지는 1차원 배열을 만들어주세요.
// B. 배열 각 원소에 여러분이 원하는 수를 넣어주세요. 단, 중복은 안 됩니다.
//    (예 : 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
// C. 배열을 랜덤으로 섞어주세요.

// D. 랜덤이 되고 난 배열에서 아래 과정을 수행해주세요.

// E. 배열의 첫 번째 자리와 다음 자리를 서로 비교해주세요.
// F. (오름차순 기준) 첫 번째 자리가 더 큰 숫자라면 자리를 바꿉니다.
//    두 번째 자리가 더 큰 숫자라면 바꾸지 않습니다.
// G. 두 번째 자리와 세 번째 자리를 서로 비교해주세요.
//    여기서 말하는 두 번째 자리는, F에서 바뀐 숫자일 수도 있고,
//    원래 있던 숫자일 수도 있습니다. 어느 쪽이든 상관 없습니다.
//    "그냥 두 번째 자리와 세 번째 자리를 서로 비교해주세요."
// H. 이후, 마지막 직전 자리와 마지막 자리까지 서로 비교해주세요.

// I. E부터 H까지의 과정을 배열의 크기만큼 반복해주세요.

// J. 반복이 모두 끝난 후, 배열을 출력하고 어떻게 나오는지 확인해주세요.

// K. 해당 화면을 찍어서 올려주세요.

// 여기까지 마치면, 거품 정렬의 기본적인 형태가 완성됩니다!
// 지금까지의 설명을 한번 코드로 만들어보고, 수행해봅시다.


// (옵션) 작성된 코드에서 혹시 논리적인 허점이 있을까요? 생각해봅시다.