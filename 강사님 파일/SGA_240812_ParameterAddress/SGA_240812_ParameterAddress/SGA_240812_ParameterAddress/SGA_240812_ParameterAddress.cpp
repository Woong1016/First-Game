#include <iostream>

// c++의 매개변수에 얽힌 문제를 이해하기 위한 샘플 오류를 바탕으로
// 여기서 벌어진 '오류'에 대해 원인 확인을 하기 위한 검사 프로젝트입니다.

// 다음 함수를 사용합니다. (8월 9일 샘플 오류 함수)
void ChangeThisFromTo(int from, int to);
// -> 실행하면 from을 to로 바꾸는 함수로 계획

// 추가 시험용 함수 (내용과 해설은 하단)
void ChangeThisAddressTo(int* from, int to);
// 실행하면 결과가???!?!!

int main()
{

    //int first = 100;
    //int second = 999999;

    //이름이 같다고 같은 변수일까? 실험을 위한 변수 이름 바꾸기
    int from = 100; // 함수 매개변수와 같은 이름
    int to = 999999;

    //std::cout << "first 숫자 : " << first << std::endl;
    //std::cout << "second 숫자 : " << second << std::endl;

    std::cout << "메인함수 from 숫자 : " << from << std::endl;
    std::cout << "메인함수 to 숫자 : " << to << std::endl;

    // 여기서 쓰인 first가 메모리에서 정확히 어디에 존재하는지
    // 확인하는 방법이 있다. (특히 C, C++에서 필수 연산자이기도 하다)
    
    // 연산자는 이후에 다시 언급하고, 일단은 확인용 코드만 확인

    std::cout << "메인함수 from이 메모리에 있는 위치 : " << &from << std::endl;

    // 변환 함수에서도 이렇게 변수의 메모리 위치를 확인
    // -> 실행 시, 매개변수의 위치가 메인함수 변수와 다르다

    // -> 컴퓨터는 변수를 이름표만 보는 것이 아니라, 위치까지 본다!

    ChangeThisFromTo(from, to); //첫 숫자를 두 번째 숫자로

    std::cout << "함수 실행 결과 from : " << from << std::endl;


    // 시험함수 사용 (내용과 해설은 밑에서 확인)
    ChangeThisAddressTo(&from, to); // 위에서 사용한 & 연산자 사용

    std::cout << "시험용 추가 함수 실행 결과 from : " << from << std::endl;

}

void ChangeThisFromTo(int from, int to)
{
    std::cout << "---함수를 시작합니다.---" << std::endl;

    std::cout << "from 인수 : " << from << std::endl;
    std::cout << "  to 인수 : " << to << std::endl;

    // 여기서 사용된 from 인수의 메모리에서의 정확한 위치 확인

    std::cout << "from이 실제로 메모리에 있는 위치 : " << &from << std::endl;

    std::cout << "<< from을 to로 바꾸기 실행 >>" << std::endl;

    from = to;

    std::cout << "from 인수 : " << from << std::endl;

    std::cout << "---함수 실행을 마칩니다.---" << std::endl;
}

//시험용 임시 함수 (해설은 밑에 있어요)
//                (상세 사용은 다른 프로젝트에서 할게요)
void ChangeThisAddressTo(int* from, int to) // Address : 메모리의 위치를 지칭
                                         // * 연산자의 의미 : 다른 곳에서 설명
{
    // 일단은 되는지 확인만 해봅시다.

    *from = to; //변수 이름 앞에 곱하기에 써야 될 것 같은 이상한 연산자를 붙였더니...
                // 결과는 실행으로 확인
}



// 일어난 일을 다시 확인

// 1. (다시 반복) 컴퓨터는 변수를 이름만 보는 것이 아니라, 위치까지 본다!

// 2. 어쩐지... 실행할 때마다 컴퓨터가 변수의 위치를 자꾸 바꾸는 것 같다?!
//    -> 컴퓨터 자원 최적화 때문 (전체 앱 자체가 메모리 어디에 있을지를
//       그때그때 달리 지정하기 때문)

// 3. 그렇게 위치가 달라지는데도 & 연산자만 써주면 컴퓨터가 그래도 변수 위치는
//    잘 잡네?!!?!


// -> 여기서 생각할 수 있는 점

// 1. "아, 매개변수에 변수이름 그냥 넣으면 안 되는구나"

// 2. "그런데 & 연산자로 변수의 위치는 볼 수 있구나?"

// 3. "그러면... 뭐가 됐든지간에 & 위치로 가서 변수의 실체를 볼 가능성도 있구나?"
//    (아무튼 &from이라고 부르면 그 위치에, int와, 100이란 내용은 있겠지)

// 4. 그러면 그러면... 그냥 처음부터 그 위치로 가서, 이름 무시하고
//    < 이 메모리 위치에 있는 변수를 직접 조작하라 > 라고 컴퓨터한테 시키면?
//    그 때는 메인함수 from도 조작할 수 있지 않을까?

//    그러니까, from이라는 이름의 변수를 조작하는 게 아니라, (컴퓨터에게 시킴)
//    from이라는 이름을 붙였던 메모리 위치에 있는 데이터를 내가 조작하겠다는 것.

// -> 이것을 위 함수에 추가해서 확인

// * 시험용 추가 함수를 실행했더니 from이 바뀐 것을 볼 수 있었다

// 이렇게 변수를 이름표가 아니라, 변수가 정말로 있는 메모리 위치에 의해

// 파악하고 조작하는 코드 문법을 "포인터"라고 부른다

// * C 이후의 모든 플밍언어는 이 매개변수 복사와 포인터 개념으로 변수를 다룬다

// 다만... C++ 이후의 모든 포인터 문법은 연산자가 필요가 없다 (생략했다)
// 그래서 자기 언어를 눈여겨보지 않았던 사람은 포인터 개념을 잘 모른다

// 반면 C++은 포인터 문법에 반드시 연산자가 필요하다. 더불어서
// 포인터 문법에 사용하는 연산자를 적으면, 반드시 포인터 문법이 되기도 한다.

// -> 그러므로 C++을 다루는 이상, 포인터 문법은 필수 중의 필수다
//    다음 프로젝트에서 포인터 문법을 쓰는 방법을 하나씩 다시 보도록 한다

