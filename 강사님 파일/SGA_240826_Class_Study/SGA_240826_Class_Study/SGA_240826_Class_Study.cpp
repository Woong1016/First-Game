#include <iostream>
#include "TestSimpleCalc.h" // 과제 코드 푼 것을 실행해보기

// 오늘의 과제 : 클래스 인스턴스 포인터, 생성자 써보기

// 1. 구조체에서 여러분이 만든 캐릭터의 데이터를 클래스로 만들어주세요.

// 2. 그 클래스에, "대표 캐릭터"를 생성자로 만들 수 있게 해주세요.
// 최애 캐릭터여도 괜찮습니다.

// 3. 해당 클래스의 인스턴스...의 포인터를 main()에서 만들어주세요.

// 4. 이어서 같은 클래스의 다른 인스턴스 포인터를 둘 이상 만들어주세요.
//    (캐릭터 전체 세 명 이상)

// 5. 만든 캐릭터들을 출력하되, 출력하는 함수는 클래스 안에서 만들어주세요.
//    main()에서는 함수 실행만 해야 합니다. (std::cout 코드 main() 안에서 금지)

// 6. (옵션) 각 캐릭터의 스테이터스는 main()에서 보이지 않게 해주세요.
//    =변수 private 처리할 것. (필요하면 겟터, 셋터 활용하기)


// 오늘의 알아볼 대상
#include "MyClass.h"

int main()
{
    // "과제 실행하기" 클래스를 실제 데이터, 인스턴스로 만든다
    TestSimpleCalc test;

    //test.Run(); // 그리고 실행한다. 끝.
    
    // -> main에서 길게 적을 필요 없이, 그리고 test 안에 뭐가 있는지 알 필요 없이
    // 그저 쓰는 입장에선 "Run을 실행하면 계산이 아무튼 된다"만 알면 된다
    // 이것이 클래스의 존재 이유 중 하나, "은닉과 은폐" 다른 말로 "캡슐화"이다


    // * 인스턴스 두 개 만드는 테스트 해보기
    //test.TwoInstances(); // 2 인스턴스 실행하고 끝.
                            // 상세 사항은 함수 내용 확인

    //--------------------------------------------------------------------


    // 클래스의 좀 더 실전적인 사용법

    MyClass myClass; // 시험용 클래스

    // myClass. // <-private 아래의 변수에 접근하려고 했지만 불가능

    // 원래 클래스 속 private은 작성한 사람이 원해서 비공개한 거니까
    // 접근 못 하는 게 당연하.....지만, 꼭 필요한 경우에도 절대로 변수 수정
    // 못 한다!! 이래서는 불편하지 않을까?

    // -> 그래서 클래스의 경우, 함수를 써서 우회적으로 변수에 접근하기도 한다
    //    ( 상세한 부분은 클래스 안에서 )

    // 클래스에서 작성한 "Set" "Get" 함수를 불러보기

    myClass.Set_X(10); // 이렇게 실행하면 클래스 속 x, y, z가 () 속 숫자로 할당
    myClass.Set_Y(20);
    myClass.Set_Z(30);

    //출력해보기

    std::cout << myClass.Get_X() << std::endl; // Get_X 실행으로 클래스 속 x를 반환
    std::cout << myClass.Get_Y() << std::endl;
    std::cout << myClass.Get_Z() << std::endl;

    // 이렇게 변수 데이터 그 자체에는 못 접하더라도 함수를 활용하면
    // 간접적으로 변수에 통제력을 행사할 수 있다

    // 여기에 사용된, 오직 변수를 수정하거나, 변수 값을 받아오는 데에만 쓰이는
    // 이런 간접 함수를....

    // 변수를 설정하는 데 쓸 때는 "셋터Setter"라고 부르고
    // 있는 변수를 반환받아 다른 곳에서 출력하거나, 활용하는 데 쓸 때는
    // "겟터Getter"라고 한다

    // -> 다만, 겟터와 셋터를 너무 많이 쓰는 것이 꼭 좋지는 않다

    // 왜냐면 결국 방법만 다르지 변수를 외부에서 볼 수 있다는 건 도긴개긴이라...

    // -> "이렇게 귀찮게 만들 바에야 그냥 public 만들면 되지 않느냐?"

    // ....원칙은 그런데 강의 진행 과정에서는 편의상, 필요상 겟터, 셋터를 써서
    // 변수를 통제할 수도 있다고 미리 알아두자...!!!

    // + 함수를 적절하게 활용하면 매개변수, 반환형을 통해
    //   숨겨진 데이터에도 어느 정도 통제권을 외부에 노출할 수 있다는 사실!!

    //----------------------------------------------------------

    // 그런데... 이 부분을 좀 더 확장하는 동시에
    // 그동안 봐온 변수들의 사용을 떠올려 보면

    // 원래 변수는, 아니 데이터는 선언과 동시에 초기화가 가능하지 않았나?

    int a = 0; // <-이거

    // 그러니까, 클래스에서 인스턴스가 나올 때,
    // 나오는 순간에 클래스 속 데이터가 다 정해지는 것도 좋지 않을까?

    // c++의 클래스에 그 기능이 있다 : 정확히는 "만들어지는 함수"

    // -> 클래스가 인스턴스로 만들어질 때, 자동으로 실행되는 함수
    //    상세 : 클래스 파일에서

    MyClass constructorSample(); // 새로운 이름의 인스턴스를 만들되
                                 // 변수 이름에 ()를 붙여서 생성자 실행

    // 생성자가 정말로 함수로서 실행됐는지 (변수가 초기화됐는지) 확인
    // .... 하니까 안 되네?

    // 이유 : 1. 생성자는 () 안에 아무 것도 없으면 그냥 써도 되니까
    //           -> 이쪽은 의미 이유가 아니다
    //        2. 생성자를 직접 부를 경우 함수를 통해 실행되는데....
    //           ...함수가 끝나면 중간 데이터가 없어지고 결과는 컴퓨터가 관리.
    //           = 어디 있는지 모른다.

    // 위 코드 시험 : ()를 붙이고, 떼고 각각 실행해볼 것
    //std::cout << constructorSample.Get_X() << std::endl; // () 붙으면 오류
    //std::cout << constructorSample.Get_Y() << std::endl;
    //std::cout << constructorSample.Get_Z() << std::endl;


    // 그래서 생성자를 이용해서 객체를 (클래스+인스턴스) 쓰는 시점부터는
    // 객체를 만들 때, 처음부터 만들어지는 데이터만이 아니라 해당 메모리 위치까지
    // 컴퓨터에 등록해서 관리 대상으로 삼는 경우가 많다 (그리고 그 편이 타당하다)

    // -> 말하자면 int 변수는 딴 곳에 만들고, int*를 쓰겠다는 것.
    // -> 다시 말해, 인스턴스의 포인터를 쓰겠다는 것.

    // 다시, 다시 말해, 클래스를 실전에서 쓴다는 것 =
    // 그 클래스를 포인터로 쓴다는 것.

    // 객체를 포인터 변수 형식으로 만들어보기

    // 기본 형태는 아래와 같다
    MyClass* pointerInstance = new MyClass();
    MyClass* pointerInstance2 = new MyClass();

    // 여기서 MyClass* : 우리가 아는 포인터 연산자, 포인터 형식
    // pointerInstance : 우리가 아는 인스턴스 이름

    // = 다음에 오는 'new' : "이름 없는 새 데이터를 만들기"라는 뜻
    // MyClass() : 이름이 없는 클래스의 생성자를 통해, 데이터만 만들기

    // -> 이름을 박탈하고 데이터를 이렇게 만들면 나중에 '이름'으로 데이터를 통제 못 한다
    // 그런데 그 데이터의 위치는 pointerInstance 안에 있다
    // -> 이 메모리 위치를 통해서 새로 만들어진 데이터를 사용자가 통제할 수 있다.

    // 새로 만든 인스턴스의 포인터가 실제로 잘 된다는 것을 확인
    
    // 셋터 함수 하나만 실행 (다른 변수 둘은 생성자가 동작했음을 확인하는 데 쓴다)

    pointerInstance->Set_X(99999); // 인스턴스의 포인터는 . 대신 -> 연산자

    // 이어서 출력
    std::cout << myClass.Get_X() << std::endl;
    std::cout << pointerInstance->Get_X() << std::endl;
    std::cout << pointerInstance->Get_X() << std::endl;
    std::cout << pointerInstance->Get_Y() << std::endl;
    std::cout << pointerInstance->Get_Z() << std::endl;

    // -> : 데이터의 세부 항목이 아닌, 메모리 위치를 기준으로 항목을 찾는 연산자
    //      "참조 접근 연산자"

    // 왜 -> 인가? : 1. 위에 적은 대로, 이름이 없어서 데이터의 '이름 호출을 통한'
    //                 인스턴스 통제가 안 돼서 (.를 못 쓰는 이유)
    //              2. new 코드를 써서 컴퓨터의 관리 하에 메모리 주소를 주고
    //                 객체를 생성하면... 생성 위치가 달라져서
    
    // 같은 데이터인데 생성 위치가 다르다고? 다르다!

    // -> 실행 중에 연산되는 데이터끼리 쌓이는 곳이 아니라
    //    아예 컴퓨터가 작심하고 관리하는 곳으로 데이터를 옮겨서 만든다
    //    (이 영역의 이름을 '힙'이라고 한다)

    // -> 그리고 여기는 한번 데이터가 만들어지면 함수가 끝났다고
    //    휘리릭 사라지지도 않는다. 찾아오기도 편하고, 메모리 참조가 빠르기도 하다

    // -> 어떤 관점에서 해석해도, 요점은 같다.

    // 클래스의 인스턴스를 생성자로 만들면 -> 포인터 형식이 더 좋고,

    // 포인터 형식으로 객체를 만들면, . 연산자 대신 "->" 연산자를 써야 한다.

    // 그러므로 다시 한번 더 연습 확인

    MyClass* moreInstance = new MyClass(); // 생성자로 인스턴스 포인터 초기화

    // 사용
    moreInstance->Set_Y(12345);
    moreInstance->Set_Z(67890);

    std::cout << moreInstance->Get_X() << std::endl;
    std::cout << moreInstance->Get_Y() << std::endl;
    std::cout << moreInstance->Get_Z() << std::endl;

    // 다시 강조 : 앞으로 클래스를 실전에서 사용하면
    // 포인터와 같이 사용하는 것은 필연
    
    // 100% 무조건 이렇게만 쓴다는 건 아니지만 정말 많은 경우 이렇게 쓴다.
    
    // 그리고 이렇게 포인터를 통해 인스턴스를 지칭하고,
    // 컴퓨터가 따로 관리하는 메모리 영역에 사용자가 직접 데이터를 만들라 지시하는

    // -> 데이터의 생성과 소멸을 컴퓨터에게만 맡기지 않고 일부 사용자가 지정하는

    // 이런 코딩을 "동적 할당"이라고 한다 (직접 할당했다)

    // -----------------------------------------------------------

    // 동적 할당과 인스턴스의 포인터까지 겪고 나면 알 수 있는 추가 사실

    // 바로 "this->" 의 정체

    // 여기서 -> : 참조 접근 연산자

    // 그리고.... this? -> 연산자의 대상이다! 그러므로... 포인터다.

    // this : "이 클래스가 인스턴스로 만들어진다면, 그 인스턴스를 지칭하는 포인터"
    //        다른 말로 '장차 만들어질 나 자신'이라는 뜻

    // 예 : MyClass에 this라는 표현이 있다면
    //      그 클래스에서 나온 mc1이란 객체의 this : mc1 자신
    //      mc2라는 객체가 또 있다면, 해당 mc2에서 실행되는 함수 속 this : mc2 자신

    // 다른 예 : 위에서 쓰인 코드를 볼 때
    // pointerInstance->Set_X(99999) 안에 this가 있었다.
    // 이 때, 해당 함수 속 this : pointerInstance를 가리킨다.
    
    // 한편 moreInstance->Set_Y(12345) 안에도 this가 있었다
    // 이 때, 해당 함수 속 this : 같은 MyClass 안에 있었지만
    // 실제로는 다른 인스턴스에 속했으므로, pointerInstance가 아닌
    // moreInstance, 바로 "지금 만들어진 자기 자신"을 가리킨다

    // 또 또 다른 풀이 :
    // this는 일단 인스턴스가 만들어지기 전에는 실체가 없다가
    // 인스턴스가 생기면 "해당 인스턴스의 메모리 위치"를 가리킨다고 본다
    // : 사실 이쪽이 가장 정확한 대답

    // * 연산자가 없는 C#, 자바, 파이썬 등의 현대 프로그래밍 언어조차
    // this라는 포인터만큼은 남겨놨다 : 그만큼 중요하고 중요하다!

}
