#pragma once
#include "Baverage.h"

// 탄산음료 클래스

class Coke : public Baverage
{
public:

    // 자식 클래스 생성자 만들기 :
    // 가격과 이름을 받은 후 (여기서 가격, 이름 : 부모 클래스에게 필요한 것)
    // 멤버 이니셜라이저에서 부모의 생성자를 실행한다 (부모를 같이 생성)
    Coke(int cost, std::string name) : Baverage(cost, name) {}
    ~Coke() {}

    // 탄산음료를 마실 때 (작성까지 헤더에서 (비추천))
    void Drink()
    {
        // 자식 클래스에서 같은 행동, 다른 효과를 내야 할 때
        // 
        // 1. 자식 클래스에 부모 클래스와 같은 이름의 함수가 없으면 :
        //    -> 부모 클래스의 함수를 그대로 이용
        //    -> 편리, 간단하지만 자식 클래스의 개성을 활용하지 못한다
        // 
        // 2. 자식 클래스에 부모 클래스와 같은 이름의 함수가 있으면 :
        //    -> 이 경우, 부모 클래스의 함수를 자식 클래스의 함수가 갱신한다.

        // 이 기능을 "함수의 갱신(override, 오버라이드)"이라고 한다.

        // -> 자식 클래스에서 별도로 수행해야 하는 기능이 있는 경우
        //    이렇게 같은 이름을 만들어서 개성적인 코드를 따로 준다

        // std::cout << name << "을 마시자 목이 톡 쏘입니다." << std::endl;

        // -> 하지만 자식 클래스를 갱신하면 부모 클래스가 반대로 무시되는 게 단점
        //    -> 이 경우, 부모 클래스의 함수를 자식 클래스 안에서 한번 더 호출

        // 말하자면
        // 1. 함수를 부르는 곳에서는 이 클래스의 함수 호출
        // 2. 이 함수는 다시 부모 클래스의 함수 호출...을 하는 것.

        // 방법 -> 부모 클래스명::함수 이름
        Baverage::Drink(); // 부모로서 가진 기능을 먼저 써주고
        std::cout << name << "을 마시자 목이 톡 쏘입니다." << std::endl;
    }

    // 가상 함수를 부모로부터 받아 작성하기
    // -> 내용 없는 함수를 오버라이드하는 것.
    virtual void Color() override
    {
        // virtual : 가상 함수 체제에서 작성했다는 의미. 실제론 하는 일 없는 정의 지시
        // override : 현재 작성된 이쪽 함수가 덮어쓰는 쪽이라고 가르쳐주는 의미

        std::cout << name << "은 까맣습니다." << std::endl;
    }
};

