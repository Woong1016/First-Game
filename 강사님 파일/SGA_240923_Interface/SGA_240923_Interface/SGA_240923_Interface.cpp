#include <iostream>
#include "Baverage.h" // 음료수 클래스
#include "Coke.h"     // 탄산음료 클래스
#include "Beer.h"     // 알콜 음료 클래스

// 예시 함수
void OrderAndDrink(Baverage* myDrink) // 음료수 클래스를 매개변수로
{
    myDrink->Drink(); // 음료수 마시기
    std::cout << "지금 실행된 대상이 음료수 클래스임을 확인합니다" << std::endl;
}

// 함수 오버로드를 사용할 경우 예시
void OrderAndDrink(Coke* myDrink) { }
void OrderAndDrink(Beer* myDrink) { }

int main()
{

    // 오늘의 진도 : 클래스 응용

    // 음료수 클래스가 있어서 써본다고 치자

    // * 원래 코드
    // Baverage* baverage = new Baverage(1000, "아무거나"); // 1000원짜리 '음료수'

    // * 인터페이스 적용 후 코드 (아래 및 Baverage 해설 참조)
    Baverage* baverage = new Coke(2500, "제로 레몬");

    // 이 음료수의 가격을 보고 싶으면 함수를 호출하면 된다
    std::cout << baverage->GetCost() << std::endl;
    // 이름도 마찬가지
    std::cout << baverage->GetName() << std::endl;

    //---------------------------------------------------

    // 그리고 이제 음료수 클래스의 파생을 만들어 써보겠다고 치자

    // -> 그럼 음료수 클래스를 상속받는 자식 클래스를 만들면 될 텐데.....

    // -> 음료수 종류에 따라 같은 행동을 해도 (같은 함수) 다른 효과가 나와야 하지 않나?

    // -> 이럴 때 어떻게 '음료수를 마신다'의 효과를 각 클래스마다 다르게 해줄 수 있을까?

    //----------------------------------------------------

    // 먼저 아까 만든 부모 클래스(의 객체)에서 마시기 함수 사용
    baverage->Drink(); // 아무거나 음료수를 마신다

    // 그리고 이제 다른 음료수도 만들어서 자기만의 함수를 사용한다면...
    // 새 객체 만들기 (자식 클래스에서)
    Coke* coke = new Coke(2000, "마시자 코-크");
    Beer* beer = new Beer(2500, "곰표 밀맥주");

    // 그런 다음, 자식 클래스의 마시기 함수
    coke->Drink();
    beer->Drink();

    //--------------------------------------------

    // 함수 오버라이드를 사용할 경우 (자식 클래스 해설 참조)
    // 자식 클래스를 통해서 부모 클래스의 함수 이름을 사용하되,
    // 개성적인 별개의 활동을 시킬 수 있다.

    // 하지만 이것만으로 완전히 자식 클래스가 활용성이 갖춰진 건 아니다.

    // 예시 1. 자식 클래스가 -> 함수를 사용하는 것이 아니라
    //         함수를 불러야 할 곳에서 -> 자식 클래스의 객체를 쓸 경우?

    OrderAndDrink(baverage); // 아까 만든 부모 객체 사용

    // 지금 이 경우, 인수 자리에 coke나 beer가 들어갈 수 있을까?

    // -> 함수 오버로드를 사용할 수도 있다
    //    하지만 자식 클래스가 지금보다 더 많아진다면?
    //    혹은 클래스를 매개변수로 받아야 할 함수가 지금보다 더 길어진다면?
    // -> 그 때마다 오버로드를 하나하나 작성할 수는 없다.

    // 예시 2. 3번째 자식 클래스를 만약 만들었는데, 함수에 Drink가 없다면???
    //        혹은 만들었는데, 이름이 다르다면???
    //        -> 의외로 협업 체제에서 자주 일어나는 일
    //           (* 옆사람, 그리고 "미래의 나"만큼 내 말 안 듣는 사람도 없다.)

    // -> 기존의 코딩은 이 두 가지를 해결하거나, 강제할 방법이 없다.

    // -> 하지만 오늘 배울 방법은 해결할 수 있다.

    // -> 바로 부모 클래스 안에, 일정한 규칙을 심어두는 것.
    //    그리고 해당 부모의 자식 클래스를, 만들 때, 부모인 것처럼 명의를 바꾸는 것.

    // -------------------------------------------------

    // 먼저 부모 클래스에서 만든 규칙을 자식 클래스에서 활용해보기

    beer->Color(); // 부모가 만든 함수 자식에서 쓰기
    coke->Color();

    // --------------------------------------------------

    // 인터페이스, 그리고 인터페이스로 만들어진 추상 클래스 활용하기

    // 부모 클래스는 이제 단독 생성이 불가능
    // 순수 가상 함수가 있으면 인스턴스 생성불가
    // Baverage* parent = new Baverage(100, "음료수");

    // 자식 클래스는 (가상 함수 내용을 제대로 적었다면) 가능
    Coke* child = new Coke(1900, "펲시!");

    // 그리고 하나 더.

    // 자식 클래스를 만드는데... 부모의 자료형으로 할당하는 것이 가능!!!

    Baverage* interfaceInstance = new Beer(2200, "테라");

    // 만들기는 Beer 클래스로 만들고, 쓰기는 Baverage로 쓴다

    // 이렇게 만든 interfaceInstance는 뭐가 좋은가?

    OrderAndDrink(interfaceInstance); // Beer로 만들었지만, Baverage 취급 가능

    // -> 일일이 매개변수로 자식 클래스를 지정해서 함수 오버로드를 하지 않고도
    // Baverage라는 부모 클래스 하나만으로 자식 클래스 모두에 대응할 수 있다.

    // 그리고 하나 더.
    interfaceInstance->Color(); // 인터페이스로 만든 자식 인스턴스의
                                // 가상 함수를 실행할 경우,
                                // 자식 클래스 쪽에서 작성해둔 내용을 실행 가능

    // 이렇게 가상 함수를 사용한 규칙 강제 (인터페이스) 방법을 쓰면
    // 자식 클래스를 부모의 규칙에 맞추어서 무조건 작성하게 강제할 수도 있고
    // 자식 클래스가 아무리 늘어나도, 어떤 자식 클래스가 와도
    // 부모 클래스 하나만으로 대응할 수가 있어서 편하다.

    // 단, 부모 클래스의 함수 중에 내용이 있는 쪽을 쓸 경우....
    // 인터페이스가 자식 클래스가 아닌 부모 쪽을 쓴다는 약점은 있다

    // -> 이 경우에는 C++의 형변환을 쓰면 된다
    ((Beer*)interfaceInstance)->Drink(); // 마시기 실행이지만...
                                         // 자식 클래스 쪽 데이터를 사용

    // 이런 코딩 방법을 업캐스팅, 다운캐스팅이라고도 하는데.... (관심 있는 분 검색)
    // 현실에서 빈번하게 쓰는 용어는 아니다
}