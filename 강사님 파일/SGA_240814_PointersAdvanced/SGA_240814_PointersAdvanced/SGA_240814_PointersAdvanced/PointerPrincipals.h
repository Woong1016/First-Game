#pragma once

void PointerPrincipals()
{
    // 포인터 기초


    // 0. 배경과 포인터의 의미

    // - 변수는 자료형, 이름, 값으로 이루어진다
    // - 이 중 '이름'은 이름만이 아닌 그 이름이 붙은 메모리 주소까지를 가리킨다
    // - 따라서 변수의 이름 앞에 & 연산자를 붙여, 변수의 메모리 속 위치를 볼 수 있다

    // - 또한 변수의 값을 보고 싶을 때, 이름이 아닌 메모리 주소를 통해서도 볼 수 있다
    // - 이렇게 메모리 주소를 매개로 변수를 다루는 프로그래밍을 참조에 의한 연산,

    // - 줄여서 '가리킴' 혹은 "포인터"라고 부른다.


    // 1. 포인터의 선언

    // - 변수 앞에 &를 붙이면 메모리의 주소를 볼 수 있다
    //   이를 참조라고 한다.

    int a = 0;
    a; // 0이라는 뜻.
    &a; // 0이라는 숫자가 들어가 있는 메모리 주소라는 뜻.

    // - 이 메모리 주소를 값으로 가지는 변수가 포인터 변수이다.
    // - 포인터 변수는 대응하는 원본 자료형 뒤에 *를 붙여서 선언한다.
    // - 포인터 변수를 줄여 포인터라고도 한다.

    int* aPtr = &a; // [int의 자료가 있는 곳]을 값으로 하는 변수
                    // 여기서는 a의 값, 0이 있는 메모리 주소를 값으로 받는다


    // 2. 포인터의 사용과 호출

    // - 포인터 변수를 호출하면 메모리 주소가 나온다.

    aPtr; // a가 있던 메모리 주소라는 뜻.
          // &a와 같다.

    // - 다른 곳에서 선언된 포인터 변수를 다시 호출할 때, 이름 앞에 *를 붙이면
    //   해당 메모리 주소에 있던 실제 데이터 값이 나온다.
    //   이렇게 메모리 주소의 본래 값을 보는 것을 역참조라고 한다.

    *aPtr; // [a가 있던 메모리 주소...] [...의 위치] 에 있는 값이라는 뜻.
           // a와 같다.

    // 최종 확인을 위한 출력

    std::cout << "포인터 기초 확인 : 출력용" << std::endl;
    
    std::cout << "------------------------" << std::endl;
    
    std::cout << "변수 a :" << a << std::endl;            // 원본
    std::cout << "변수 a가 있는 곳 :" << &a << std::endl;  // 메모리 주소
    
    std::cout << "------------------------" << std::endl;

    std::cout << "변수 a의 포인터 :" << aPtr << std::endl; // 포인터 변수
    std::cout << "포인터의 실제 내용 :" << *aPtr << std::endl; // 역참조

    std::cout << "------------------------" << std::endl;


	// 추가 내용 : 포인터의 값의 의미를 다시 돌아보면
	// "주소" 이다 그말은 포인터의 내용은 양이나 척도의 의미가 없다
	//(그보다는 차라리 "좌표" 에 가깝다 )

	// int = 숫자ㅑ
	
	// 하지만 int* = 숫자 아님 (숫자 데이터가 있는 컴퓨터의 어딘가란 뜻)


	// 따라서 아래 연산은 성립하지 않는다.

	int* bptr = &a; // 포인터에 이어 또 다른 포인터가 있다고 할 때
	// aptr = aPtr + bPtr; // 이렇게 포인터끼리 사칙연산을 할 수는 없다

	// 비유하자면 남대문과 동대문을 덧셈할 수 없는 것과 비슷

	// 대신 좌표로서의 추가 연산은 가능
	//bPtr = aPtr + 1; // 이게 되네? 당연히 된다.

	// 이 역시 비윻자면 동대문에서 북쪽으로 몇 번지 가
	// (현실에 있는 주소는 아니지만) 대략 의미가 성립하는 것과 같다

	// 이부분은 나중에 설명

}

