#pragma once

// 주석 불필요 : 자가 검색을 더 추천

// "메모리 구조"

// 컴퓨터는 앱을 실행하면 그 내부에 존재하는 프로그래밍 지시들을
// 코드에서 용도에 따라 구분을 한다

// 그리고 코드의 구성, 목적, 지시한 작업 등에 따라
// 메모리 안의 다른 영역에 각각 나누어 배치를 한다

// -> 그래서 빠르고 반복 작업은 어려운 곳, 느리지만 마음대로 편집 가능한 곳...
//    ...하는 식으로 영역끼리도 용도를 나누어서 효율적으로 실행하고자 한다.

// 이 때, 컴퓨터가 스스로 설정하는 메모리의 구조 중,
// 앱의 실행에 관여하는 부분은 다음 네 가지로 구분된다

// 1. "코드" 영역

// 프로그램을 구성한 원본 코드 내역(텍스트) 그 자체를 담아두는 공간
// 모든 것의 기초라고 할 수 있고, 실행 중에 참조할 데이터가 필요하면
// 여기서 코드를 다시 보고 실행한다. 가장 빠르고, 가장 편집이 힘들가

// 엔드 (최종 실행용 앱) 프로그래머, 특히 게임 프로그래머 입장에서는
// 사실상 손 대기도 힘들고 손 댈 필요도 없는 영역이기도 하다.

// 2. "데이터" 영역

// 프로그램을 최초로 구현하기 위해서 꼭 필요한 데이터를 담아두는 공간
// 구체적으로는 함수 지시사항, 전역 변수, (나중에 알아볼) "정적 변수" 등을
// 이 영역에 저장한다. 코드와 마찬가지로 한 번 실행되고 나면
// 앱이 돌아가는 중에는 사실상 수정이 없는 거나 마찬가지

// 보통은 메모리의 부담을 줄이거나, 반대로 메모리의 부담을 늘려서라도
// "빠르게 보고 참조할 수 있는 데이터"를 만들어주기 위해서
// 전역변수를 추가하거나, 빼는 방식으로 이 영역에 간접 개입을 하는 편

// 그러니까, 전역변수가 많아진다 = 사양 높아짐. 속도 빨라짐.
// 전역변수를 줄이고 함수 안에서 변수를 만들고 지운다 (지역변수) = 사양 낮아짐, 느려짐



// 이 다음부터가 실질적으로 어떤 프로그래머든 신경써야 할 대상이 된다

// 3. "힙" 영역 (Heap, 축적)

// 코드를 통해서 사용자가 미리 만들어두라고 컴퓨터한테 시킨 데이터가 들어간다
// (대표적으로 'new' 지시를 써서 만든 인스턴스 포인터 객체)
// 그 밖에도 함수가 힙에 들어가는 데이터를 발생시키기도 한다
// 이렇게 사용자의 지시에 의해서 컴퓨터가 일부러 이쪽에 할당한 데이터를
// "동적 할당 데이터"라고 통칭한다.

// -> 데이터 영역처럼 힙도 실행 전에 어느 정도 사용자의 의지에 따라 부담량이 달라진다
//    힙이 많다 : 메모리에 담긴 데이터가 많다 = 여유 공간이 적다

// 힙은 데이터보다는 참조가 느려서 힙을 쓰고 안 쓴다고 속도가 큰 영향을 받진 않고
// 대신 "여유 공간"의 존재가 큰 변수가 된다

// (재정리) 힙이 많다 = 여유 공간이 적다 = 실행 중에 프로그램에서 발생하는
// 추가 데이터가 많을 경우 (게임의 하이스코어라든가 채팅로그라든가)
// 프로그램이 큰 부담을 받을 수 있다.

// 반면에 프로그램이 힙을 많이 주면 줄수록 프로그램의 실행에 필요한 기반 데이터가
// 충분히 확보된 것이기 때문에 실행 중에 오류나 로딩 문제 등이 발생하지 않을
// = 안정성도 높아진다. (게임으로 치면 랙 감소)

// 장단점에 따라 힙을 얼마나 쓸 것인지 정하는 편 -> 나중에.
// 간단히 말하면, 최적화 단계에서 같은 데이터를 힙에 둘 건지 다른 곳에 둘 건지
// 이 부분을 정하는 게 프로그래머의 과제가 될 것.

// 이런 영역에 이어서, 마지막으로 프로그램 자체에서 스스로 발생시키는 영역이....


// 4. "스택" 영역

// 실행 중에 앱이 발생시킨 데이터들 (컴파일에 의한 생성 데이터, 지역변수,
// 동적할당 시에 만들어진 실질 데이터 말고 그 데이터를 담은 '포인터 변수' 그리고
// 앱 실행 중에 추가로 나온 데이터라면 무엇이든. 순간적인 보스의 체력 변화, 채팅로그 등)

// 이 모두가 무엇이든 메모리에 쌓여서 관리되는 곳이 바로 스택(stack, 적재)이다

// 컴퓨터 입장에서는 가장 자유롭게 다루는 메모리 영역이지만, 가변성이 높아서
// 그때그때 어떤 데이터가 어디에 있는지 가장 알아보기 힘든 곳이기도 하다

// = 스택 비중이 높다 = 가장 느리다 = 가장 메모리 사양 요구가 낮다
//                                  적은 메모리로 시작할 수 있어서

// 이 밖에도 코드 실행 중에 컴퓨터가 만들게 되는 새로운 변수...
// 실행 중에 반복문 과정에서 발생하는 연산의 결과....
// 나중에 우리가 배열의 크기를 (혹은 문자열의 길이를) 마음대로 할 수 있다면
// 그 때 추가하라고 시킨 새 문자들.... 이 데이터들도 마찬가지로 스택으로 간다

// 요약 : 실행하고 나서 만들어질 (혹은 {} 안에서 선언이 시작된 변수들)
//        이런 데이터들은 모두 스택이라고 우선 생각해도 괜찮다.

// 프로그래머 입장에서도 가장 만만하면서 동시에 가장 무서운 메모리 영역

// -> 만만하다 = 기본 요구 사양이 낮기 때문 (그냥 함수 안에서 아무거나 만들면 OK)

// -> 무섭다 = 반복문 잘못 돌리면 연산하다가 앱이 오류날 수도 있기 때문
//            (반복문에서 너무 많은 연산을 하다가 오류 나본 경험 있는 분?)

// * 그리고 스택이 데이터 양을 감당 못해서 터져 나가는 형태의 오류를
//   "스택 과부하" (stack overflow) 라고 한다


// --------------------------------------------------------


// 메모리 영역을 알아보고 나면 지금 우리가 알 수 있는 사실

// 1. 전역변수는 만능이 아니다 (다 전역변수로 만들면 앱이 느리다!)
//    옛날에는 사양도 문제였지만... 지금은 그런 시대는 아니고.

// 2. 앱이 얼마나 많은 메모리를 쓰는가는 우리 코드에 달렸다. (원론이지만)

// 3. 어느 정도 범위 안이면 우리가 실행할 앱이 컴퓨터 메모리를 얼마나 쓰게 할지
//    그냥 마음대로 늘렸다 줄였다 할 수도 있고, 그래도 된다. 범위 안이라면.

// -> 적절한 기능만 있다면, 우리는 데이터 자체의 집합, 배열 등을
//    마음대로 늘렸다 줄였다 해도 괜찮았다. 단지 그런 기능을 몰랐을 뿐.