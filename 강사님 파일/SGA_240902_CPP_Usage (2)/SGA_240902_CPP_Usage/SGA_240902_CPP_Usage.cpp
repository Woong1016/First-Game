#include <iostream>

// 과제 : 문자열 한번 써보기

// main에서 작성해도 되고, 따로 클래스를 만드셔도 됩니다.

// 1. 내가 좋아하는 캐릭터의 스탯을 하나의 문자열로 작성해주세요. (이름 제외)
//     ㄴ 캐릭터 스탯은 ,(쉼표)로 구분해주세요.

// 2. 내가 좋아하는 캐릭터의 이름을 별도의 문자열로 작성해주세요.

// 3. 2.에 1.을 합쳐주세요. (이름 -> 스탯)

// 4. 합쳐진 3. 문자열을 쉼표로 나누어주세요. (계속)

// 5. 나뉜 문자열들을 차례로 출력해주세요. (이 과정에서 반복문 필요할 것)

// (옵션) 과제가 끝난 후, c++의 다른 제공된 함수들이나 네임스페이스 등을
//        찾아보시는 것도 좋겠습니다.

#include "UseInheritance.h" // 복습 겸 부모-자식 관계 사용

// 문자열 사용을 위한 기능 집합들
#include <stdlib.h> // 표준 기능 집합. 문자열 함수가 포함되어 있습니다.
//#include <string> // C++ 맞춤 문자열 기능 집합
#include <string.h> // C++ 맞춤 문자열 기능 집합...의 신버전
#include <cstring>  // C와 C++에 공통적으로 쓰이는 문자열 기능 집합. 약간 구식.

// 팁 : 오늘은 필요에 따라 위 세 파일을 동시에 쓰지만,
//      사실 동시에 쓰지 않는 편을 추천합니다. (이유는 후술)

// 우리가 만든 오류를 위한 헤더 포함하기
//#include "CustomError1.h"
//#include "CustomError2.h"

// 우리가 만든 네임스페이스
#include "CustomNamespace.h"

using namespace CustomNamespace2; // 커스텀 네임스페이스2를 기본값으로

using namespace std;

int main()
{
    //복습 코드
    UseInheritance* review = new UseInheritance();
    
    //복습 실행
    review->Run(); // 복습 확인시 주석 풀고 실행해봅시다


    // 오늘은 조금 쉬운 부분을 다시 보도록 합시다.
    
    // 오늘의 진도 1 : C++의 문자열 관리 함수....의 자주 쓰는 기능 일부

    // 1) 문자열 복붙하기 strcpy_s
    //    실행하면 문자를 새로운 문자로 교체합니다.

    char* word1 = new char[129]; // 한글 64자까지 버틸 수 있는 포인터 공간 준비

    strcpy_s(word1, 9, "computer"); // 문자열 복붙 (혹은 "덮어씌우기")
                                    // 메모리 어딘가에 computer라는 문자를 생성
                                    // 해당 메모리의 위치를 word1에 할당

                                    // 매개변수 : word1 <- 복붙한 문자 데이터가 가야 할 곳
                                    // 9 <- 이어지는 문자의 길이 + 1 ("지금 문자열이 끝납니다")
                                    // computer <- 실제로 덮어씌울 문자열(텍스트)

    // strcpy_s의 실행 결과
    std::cout << word1 << std::endl;

    // 2) 문자열 측정하기 strlen
    //    실행하면 문자열의 길이를 int로 반환합니다.

    char* word2 = new char[129]; // 여기에 숫자를 크게 주는 이유
                                 // : 나중에 긴 글자가 와도 버티게 하려고

    const char* sampleText2 = "apple"; // 샘플 텍스트
    int lengthOfText2 = strlen(sampleText2); // 위 샘플 텍스트에 할당된 글자 크기

    strcpy_s(word2, lengthOfText2 + 1, sampleText2); //lengthOfText2 대신
                                                     //strlen(sampleText2) 직접 사용해도 됩니다

    std::cout << word2 << std::endl; // 샘플 텍스트를 씌운 것
    std::cout << lengthOfText2 << std::endl; // 텍스트 크기

    // 참고 : strcpy에 사용한 word2를 word1로 바꾸어도 코드가 통한다
    //       (word1에 할당된 "computer"를 무시하고 "apple"이라는 새 데이터 할당)


    // 3) 문자열 연장하기 strcat_s : cat은 conCATenation의 줄임말
    //    (일반적으로 생각하는 "복사하기" 혹은 "합치기"의 함수는 이쪽)

    // 위에서 만든 문자를 하나로 합쳐보기

    int lengthOfText1 = strlen(word1); // 문자열1의 길이 내기
    strcat_s(word1, lengthOfText1 + lengthOfText2 + 1, word2);
            // 매개변수(왼쪽부터) = 원본 겸 결과가 담길 표적 데이터 (포인터),
            //                     해당 데이터에 들어가야 할 문자 개수,
            //                     합치려는 문자열,
    std::cout << word1 << std::endl;

    // 4) 문자열을 지정 표시로 구분하기 strtok : tok는 표시TOKen의 줄임말
    //    풀어서 해설하면 "지정한 표시로 문자열을 왼쪽, 오른쪽으로 나누기"

    char* word3 = new char[129];
    
   char* wordRemains = NULL; // NULL = 주소 정보를 확정하지 않은 빈 포인터
                   // 정보들이 아직 미정이라서 다중 포인터 등으로
          
                    // 응용이 가능해진다
   
    word3 = strtok_s(word1, "r", &wordRemains);
   

                                // 매개변수 : word1 = 원본 텍스트(의 포인터)
                                //           "r" = 텍스트를 쪼개는 기준
                                // 실행하면 r 왼쪽과 r 오른쪽으로 쪼개진다
                                // wordRemains : 남은 텍스트가 가는 곳
    
    std::cout << word3 << std::endl;    // 자른 결과

    std::cout << wordRemains << std::endl; //자르고 남은 텍스트

    // 사용하면 표시로 지정한 글자를 기준으로 왼쪽과 오른쪽으로 잘린다
    // -> 표시 그 자체는 왼쪽, 오른쪽 결과에 포함되지 않는디
    //    (computer가 compute로 바뀐다)

    // 나중에 이 함수를 사용할 때는 보통 자르기에 적합한 기호 등을
    // 원문에 포함시키는 경우가 많다 (쉼표나 마침표 등으로)

    // 예 : 원문은 1, 2, 3, 4, 5라는 텍스트
    //      자를 때는 strtok_s(원문, ",", 나머지) 이렇게 사용


    //---------------------------------------------------------

    // 오늘의 진도 2 : '중복되는 함수'와 '함수의 영역 범위'에 대해서

    // 배경 : 위에서 문자열 코드를 쓸 때 _s를 안 붙이면 오류가 나는 일부 함수 존재
    //        왜? 같은 함수 정의는 있지만, 해석이나 취급이 다른 헤더가 있어서
    //        (main 함수 위에 너무 많은 문자열 헤더를 썼다!)

    // 이렇게 헤더가 여럿 붙으면 원칙적으로 중복으로 검사되지 않지만
    // 사실상 중복이나 다름없는 함수 작성이 발생할 수도 있다.

    // 오류 일으켜보기 : 헤더 작성 후 함수 확인

    //int a = BrokenCalc(10, 3); // 망한 계산 불러오기
    //int b = BrokenCalc(10, 3); // 같은 이름의 함수 두 번 부르기

    // 출력
    //std::cout << a << std::endl;
    //std::cout << b << std::endl;

    // 실행하는 순간 오류 : 실행하려고 보니까 함수에 문제가 있더라

    // * 그나마 CPP 기본 제공 함수 등은 이런 문제가 많이 줄어서
    //   중복하는 이름이 쓰여도 실행은 되게 만들어뒀지만....

    // 그럼에도 불구하고 A 함수와 B함수가 서로 달라 한쪽이 무시되거나,
    // A 함수가 다른 헤더에서 "쓰면 안 되는 함수"로 지정된 탓에
    // A 함수를 쓴다고 했다가 오류가 나거나... 하는 일이 생긴다.

    // 이 문제를 해결하는 방법 : 구조체, 클래스와 크게 다르지 않다

    // -> 데이터를 구조체, 클래스 등으로 묶었던 것처럼
    
    // 함수 역시 필요하면 별도의 영역으로 모아서 묶어줄 수 있다.
    
    // 그리고 그렇게 하나로 묶어서 호출할 수 있도록 이름을 부여한 것을
    // 코드의 명명된 영역, 혹은 "네임스페이스"라고 한다.

    // * 네임스페이스 헤더 작성 후 사용해보기

    //int a = Operation(10, 3); // 이렇게는 사용 불가능

    // 네임스페이스를 사용할 때는 마치 클래스처럼
    
    // 네임스페이스를 먼저 지정을 해주고 뒤에 :: 연산자를 붙여줘서
    // "어느 영역의 함수를 쓸 것인지" 확실히 해준 다음에
    // 거기에 있는 함수를 사용

    int a = CustomNamespace1::Operation(10, 3);

    int b = CustomNamespace2::Operation(10, 3);

    int c = CustomNamespace1::Mult(10, 3); // 네임스페이스 1 함수 사용가능
    //c = CustomNamespace2::Mult(10, 3); // 네임스페이스에 없으면 함수 호출불가

    std::cout << a << std::endl; // 두 숫자를 출력
    std::cout << b << std::endl;

    // 이렇게 네임스페이스를 이용하면 함수 호출 자체도 안전해지고
    // 더불어 철자가 겹치는 함수를 사용할 때, 어느 네임스페이스에 속하는지
    // 어느 함수의 설정을 사용할지 지정해줄 수가 있다.

    // ---------------------------------------------

    // 네임스페이스의 활용 간단 팁

    // 특정한 네임스페이스를 유난히 자주 쓴다든가,
    // 특정 네임스페이스의 설정값을 디폴트로 지정하고 싶다면
    // main 위쪽에 'using namespace 네임스페이스이름' 이라고 쳐서
    // 해당 네임스페이스를 기본값으로 만들어줄 수 있다.

    int d = Operation(10, 4);
    std::cout << d << std::endl; // 결과는 6

    // main 위에 using namespace CustomNamespace2를 적은 결과
    // Operation이라고 하면 자동으로 CustomNamespace2 안의 함수인 것처럼
    // 컴퓨터가 이해해서 자동으로 빼기 계산 수행

    int e = CustomNamespace1::Operation(10, 5);
    std::cout << e << std::endl; // 결과 15

    // 네임스페이스 기본값이 설정되었더라도 직접 네임스페이스 이름을 호출하면
    // 여전히 해당 영역 내의 함수를 불러올 수는 있다.

    // 팁 : 우리가 지금껏 쓰던 std:: 이것 역시 "C++ 기본 함수 영역"이란 이름의
    //      네임스페이스 중 하나였다!

    // 그러므로 using namespace std; 라고 적고 cout을 줄여 써보자

    cout << "Hello!" << endl; // std:: 없이 출력 코드 써보기
                              // ㄴ된다!

    // -> std 역시 네임스페이스다! 줄여쓸 수 있다!

    // -> 그런데 강사는 왜 안 줄여 썼을까?

    // 1. 그냥 귀찮아서
    // 2. 줄여쓰기 전에 설명을 해야 할 것들이 남아서 (바로 오늘의 진도)
    
    // 3. "using을 사용하면 네임스페이스의 기본값이 정해진다"는 것 때문
    //    위에서 말했듯 함수마다 헤더의 상세 코드나, 허용 범위가 달라질 수 있는데
    //    어떤 함수는 A 헤더가 기본값일 때 편하고, 어떤 함수는 B헤더가 더 편하면
    //    그 때는 기본값을 굳이 설정을 안 하는 게 더 편해지기도 해서.

    // -> 경우에 따라선 타자 칠 땐 귀찮아도 std::을 붙여주는 편이
    //    차라리 속 편한 경우도 생긴다. 그게 세 번째 이유

    //----------------------------------------------------------

    // 다 쓴 데이터 앱 종료 직전에 폐기하기
    // delete word1; // 지금은 꼭 안 이래도 되지만, "지우기" 실습을 위해 써보기
    //              // 1. 배열 생성은 delete하고 호환성 떨어짐
    //              // 2. 어차피 main 끝나면 의미 없음
    //
    // delete word2;
    // delete word3;
}