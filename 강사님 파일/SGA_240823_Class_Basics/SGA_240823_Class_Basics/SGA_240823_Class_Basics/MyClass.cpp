#include "MyClass.h" // 클래스 헤더가 미리 포함되어 있음
                     // (혹시 안 됐을 경우 직접 포함하면 된다)

// 클래스 함수 실제 내용 작성 순서는 조금 바뀌어도 된다
// (main() 위아래에서 함수 작성하는 것과 비슷한 이치)

#include <iostream> // 입출력 기본기능

// 클래스 함수 작성 시 필요한 문법

// 클래스 cpp 파일은 헤더가 읽어주지만, 함수까지 다 알아서 읽어주진 않는다
// 클래스 함수를 작성할 때는, 해당 함수가 정확히 어느 클래스의 함수인지를
// 코드로 정확하게 표현해주어야 한다.

// 클래스 이름을 그래서 정확히 대응시켜서 작성하면 아래처럼 된다
void MyClass::PrintAnB() // a와 b 출력하기
{
    // 함수 이름 앞에 '클래스이름::' 코드를 같이 붙여주면
    // 해당 함수가 지정된 클래스에 소속한 함수라고 컴퓨터가 알아듣는다

    // 출력하기
    std::cout << a << std::endl; // 함수와 클래스명이 일치하면
    std::cout << b << std::endl; // 여기 있는 a, b는
                                 // 클래스 헤더에 있던 그 a, 그 b이다

    // 따라서 MyClass.h에 있던 a, b를 모니터에 출력한다

    // * std:: <- 이거도 혹시 클래스임? 대충 그 비슷한 거 맞다.
    //            (진짜 클래스는 아니지만 유사한 것)
    //            std 속 cout 기능을 쓰겠다고 그동안 우리가 작성해온 것
}

void MyClass::SetNumberToAnB(int a, int b)
{
    // 작성하고 보니... 매개변수 a와, 클래스 속 a가 이름이 같은데?
    // 이 때, 클래스의 경우 이 둘을 구분할 방법이 있다.

    // 왜냐면 클래스의 특징 중 하나는 독립 - 클래스 속 모든 데이터는
    // '이 클래스의 것'이라고 소속되고 지칭될 수 있기 때문

    // 특히, 그 클래스가 함수를 실행하는 당사자다?
    // 더욱 더 지칭할 지시어가 명확하다.

    this->a = a; // this-> : "이 클래스의"라는 뜻
                 // 더 정확히는, "이 클래스로부터 나온 인스턴스의"라는 뜻
    this->b = b; // 따로 수식이 없으면 그냥 나오는 a, b는 매개변수
}

int MyClass::AddAnB()
{
    return a + b; // 더해서 반환하기
}