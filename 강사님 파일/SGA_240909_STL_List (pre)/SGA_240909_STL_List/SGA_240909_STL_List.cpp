#include <iostream>
#include "Shop.h"


//과제제제제제제제제제제(리스트 이해)

//1. 리스트에서 우리는 인덱스 [] 연산이 불가능하다는 것을 알았습니다.

// 그런데 불가능하다고 진짜로 인덱스 없이 리스트를 쓰면 불편합니다.
// 그러므로 인덱스를 이용해서 리스트에 데이터 호출 ,추가 ,삭제를 시켜주려 합니다.
//
//우리가 직접 만든 함수를 이용해서 말이죠
// *리스트와 인덱스를 매개변수로 받아서 해당 리스트에서 데이터를
// 인덱스 호출, 추가 , 삭제할 수 있도록 함수를 작성해주세요.
// (*힌트는 오늘 진도 안에 다 있습니다)

//2. 리스트에 대해 다시 한번 더 인터넷이나 교재를  찾아보시고 필기해봅시다
//	그리고 필기한내용을 카페에 올려주세요

//3. 링크드 리스트에 대해 알아보았습니다. 여기에 대해서도 찾아보고 필기합시다.
//	그리고 필기한 내용을 카페에 올려주세요

//4. (옵션) 호기심이 동하는 분은 링크드 리스트를 C++에서 만들어보기
//			데이터와, 다음 데이터의 포인터만 있으면 링크드 리스트를 구성하기 위한
//			원소 클래스, 혹은 구조체를 만들 수 있습니다.

//STL 자료구조 : 리스트 + 연결리스트
#include <list> // 리스트 자료구조 기능

int main()
{
    Shop* shop = new Shop();
   // shop->Run();


	//담배피고싶어 담배피고싶어 담배피고 싶어 담배피고 싶어


	// 오늘의 진도 : 리스트

	//리스트란 벡터와 마찬가지로 자료 구조 , 즉 데이터의 집합 관리 방법 중 하나

	//혹은 거칠게 말하면 벡터 같은 것 혹은 배열 같은 것 ... 이기 한데

	//벡터의 가장 큰 특징인 "배열을 닮았다." 라는 요소가 리스트에는 없다.
	//=> 이게 가장 큰 결정적 차이

	//일단은 만들어보자

	std::list<int>intList; // 리스트 선언
							// 벡터와 마찬가지로 <>를 통해
							// 어떤 자료형의리스트인지 선언 필요 
							// (벡터와 마찬가지로 , 어떤 자료형이든 OK)

							// *이것도 나중에 알아볼 "템플릿"에 속한다

	// 리스트에 자료를 추가해보기 (+삭제해보기)

	intList.push_back(100); // 100추가
	intList.push_back(200);
	intList.push_back(300);
	intList.push_back(400);
	intList.push_back(500);
	intList.push_back(600); // 600까지

	intList.pop_back();// 마지막 원소 삭제 600삭제
	//벡터와 마찬가지로 데이터 추가도 삭제도 잘된다

	//그러니 출력해보자

	for (int i = 0; i < intList.size(); i++)
	{
		//std::cout << intList[i] << std::endl;
		//=> [] 연산자를 썼더니 안돼

		//intList.at(n) ; 이함수도 없다

		//리스트가 벡터와 데이터를 저장하는 방식이 다르기 때문
		// 더불어 순번 연산자 ([]표시)의 의미 때문이기도 하다.

		//*리스트는 데이터를 배열처럼 저장하지 않는다.

		//그 말은 , 데이터를 저장할 때, 이전 데이터와의 메모리 관꼐를 따지지 않는단 뜻
		//=> 이전 데이터의 위치 그 다음에 새로운 데이터를 추가하고....

		// 이렇게 배열처럼 쓸 수 있게 만들어주지 않는다.

		//떡갈비 먹고 싶다

		// 벡터와 비교하면 벡터는 데이터를 배열처럼 쓸 수 있게 하기 위해
		//전체 데이터의 여유 공간을 호가보한 후 , 전체 배열을 통복사한다.
		//그렇기 때문에 원소 추가, 삭제는 느리고, 호출은 빠르며,
		//데이터 단위를 포인터로 나타내는 []연산자를 쓸 수가 있다.

		//반면 리스트는 여유 공간에 새 데이터를 하나 새로 넣기만 한 다음에
		// 이전 데이터에서 새로운 데이터로 찾아갈 수 잇도록 참조 포인터를 각각
		//준다. (1번째 데이터에서 2번째 데이텅 찾아가기 가능 2번째는 3번째....)
		// 그렇기 때문에 원소 추가 , 삭제는 빠른 편이지만 (통복사를 안하니까)
		//호출이 느리고 , 뿐만 아니라 []연산자를 쓸 수 없다. (at함수 포함)

		// 그렇다면 리스트에서 원소 호출은 어떻게 해야한단 말인가요
	
	}
	// 요약 : 리스트는 []연산 불가 

	// 하지만 클래스 내에 있는 포인터 클래스는 여전히 쓸 수 있다.
	//= std::list<>::iterator <- 이가
	std::list<int> ::iterator iter = intList.begin(); // 이건 된다

	//그러므로 포인터 클래스를 응용하면 리스트도 출력, 호출이 가능하다
										//시작 상황: 부연 필요없음 (지금 그대로)
										// 반복 조건: 반복자가 마지막이 아닌 동안
										// 반복할 때마다 : 반복자가 다음 차례로
	for (; iter != intList.end(); iter++)
	{
		std::cout << *iter << std::endl;
	}
	//intList.insert(3, 30000); // insert 사용불가  ([]연산기반)

	iter =intList.begin(); // 반복자 초기화
	iter++;					// 반복자를 다음차례로 1+
	iter++;					// 반복자를 다음차례로 1+
	iter++;					// 반복자를 다음차례로 1+
	// 위 연산으로 위치가 옮겨진 iter를 이용해서 다른 함수로 데이터 추가는 가능

	intList.emplace(iter, 30000); // 반복자로 위치가 지정된 곳에 30000추가
									// emplace : insert 비슷한 함수. 반복자 기반
									//	emplace도 벡터에서 같이 쓸 수 있다.
	//다시 출력확인
	iter = intList.begin();
	for (; iter != intList.end(); iter++)
	{
		std::cout << *iter << "//"; // 칸 구분

	}
	std::cout << std::endl; // 마지막에 줄 바꿈

	//중간 데이터 삭제도 비슷한 방법으로 쓸 수 있다.

	iter = intList.begin(); // 반복자 초기화
	iter++;					// 반복자를 다음차례로 1+
	iter++;					// 반복자를 다음차례로 1+

	intList.erase(iter); // 반복자 위치의 데이터를 삭제  

	iter = intList.begin();
	for (; iter != intList.end(); iter++)
	{
		std::cout << *iter << "=="; // 칸 구분

	}
	std::cout << std::endl; // 마지막에 줄 바꿈


	//리스트에서 중간에 emplace, insert , erase를 쓰더라도
	// 각 데이터의 순서 관꼐를 나타내기 위한 참조 포인터는 그떄그때
	//추가 , 삭제되는 데이터에 맞추어서 조정되므로
	//중간에 데이터를 넣다가 순서가 꼬이지는 않는다

	// 코딩하는 사람이 헷갈리지만 않는다면


	//====================================================
	// 
	// 
	// 벡터와 리스트 차이?
	// 
	// 벡터: 데이터를 하나로 묶어서 부르기 편하게 만든, 배열같은 자료 구조
	//		데이터가 하나씩 들어오고 나갈 때마다 전체데이터의 여유공간 따짐
	//		그 과정에서 모든 데이터가 추가, 삭제될 때마다 위치가 100% 바뀐다
	//		심지어 메모리에 여유가 있어도 통복사할 여유공간이 안보이면
	//		벡터는 그냥 터진다. (실행 중에 오류를 일으킨다)
	//		메모리에 여유가 극단적으로 없을 떄는 위험할 수도 있고
	//		여유가 있어도 구성요소가 수시로 추가되고 지워지는 환경이면 느리다.
	//		반면, 딱 한번 제대로 만들어서 두고두고 써먹는 환경이면 최적의 성능
	// 
	// 
	// 리스트 : 일단 데이터를 여기저기 아무데나 심어두고 , 그 다음에 연결한 구조
	//			(벡터 = 분류 후 할당, 리스트 = 할당 후 분류... 라고 퉁칠 수 있음)
	//			메모리 여유가 여기저기 조각이 나 있어도 데이터가 유연하기 관리
	//			데이터 추가 , 삭제 때도 새 데이터를 넣은 후 참조 주소만 바꾸면 OK
	//			구성요소가 수시로 추가되거나 지워지는 환경일 땐 리스트가 빠르다
	//			또한 , 데이터가 한번 기록된 후 계속 유지되어야 할 떄도 리스트가 안전
	//			대신 호출할 때 매우 느리다(C++ 기준 야 1/10000초 ~ 1/1000초 )
	// 
	// 
	//벡터도 리스트도 장단점이 있어서 + 개발자 취향도 어느정도 있어서 
	// 차라리 단점을 좀 감수하더라도 개발상의 편의를 희생할 수 없다.
	// 그때그때 벡터 혹은 리스트가 각각 선호되는 경향이 있다.
	// 
	// => 최선은 목적에 맞게 가장 빠른 자료 구조를 선택할 수 있는 것이 최고
	// 
	//	
	// 
	// ===============================================================
	// 
	// 같이 볼 대상: "링크드 리스트" 혹은 '연결 리스트' 
	// 
	// -> 리스트의 단순화한 형태
	// 
	// 클래스 , 혹은 구조체 안에 데이터와 , "바로 내 다음의 데이터 위치"만 갖고 잇다
	// 
	// 예: 데이터 1 : 정수 데이터 1 + 다음 포인터 2 
	//	   데이터 2 : 정수 데이터 2 + 다음 포인터 3
	// 
	// 포인터에 포인터를 이어서 짚어나가면 전체 리스트를 알 수 있는
	//		C++ 리스트 클래스의 가장 극단적인 단순화 형태
	// 
	// => 참조라는 개념에서는 리스트와 유사하다 (리스트가 완전히 이해되면
	//											링크드 리스트도 이해하는 것)
	// 
	// 링크드 리스트가 실제로 쓰이는가? 당연.
	// 
	// => 게임 속의 "웨이포인트" // 퀘스트의 "달성 조건"
	// 
	// 
	// 		
	// 좀더 열심히 하면 담배를 필 수있어요 
	// 
	//맘스터치 먹고싶다 배고파 배고파 배고파 배고파 배고파 배고파 배고파 배고파 배고파

	//휠렛버거 먹고 싶어어어어
}