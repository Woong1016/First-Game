// SGA_240927_TSingletons_FPointers.cpp

#include <iostream>
#include "SampleTSingleton.h" // 싱글턴(의 자식 클래스) 사용

#include "Functions.h" // 함수들 (우리가 작성한 함수 선언)

#include <functional> // c++의 함수관리 기능

int main()
{
    //싱글턴 써보기
    std::cout << SampleTSingleton::Get()->data[7] << std::endl;

    //인라인 함수 써보기
    std::cout << SampleTSingleton::Get()->Add(10, 3) << std::endl;
    //호출은 'Add'인데, 실제로는 실행할 때 이 기능이 있는 헤더로 가지 않고
    //텍스트가 마치 (int x, int y) { return x + y; }가 실행되는 것처럼
    //처리를 해준다.

    // -> 실행 안정성에 도움, 하지만 속도, 특히 파일 작성 속도 (컴파일 속도)
    //    ....에 매우 악영향을 준다

    //------------------------------------------------------------------

    // 오늘의 진도 : 함수의 대기와 변수처럼 쓰기

    // 먼저 헤더에서 만든 함수를 써보자

    Print(); // 아무거나 글자 찍기
    PrintThese(11, 22); // 인수 출력
    AddAndPrint(10, 3); // 덧셈 출력
    Amugona(1111, 2222);    // 내용은 없으니 의미는 없지만....

    // 그런데, 만약 우리가 이 함수를 이렇게 코드에서 바로 실행하라 지시하지 않고...
    // ...앞서서 대기를 시킨다고 하면 어떨까?

    // A가 벌어지면 Print가 실행된다! 같은 상황에서
    // 조건문을 써도 되지만, 그냥 Print라는 함수 데이터를 다른 곳에 저장해두고 싶은 거

    // 변수였으면? 값을 다른 변수에 백업하거나, 포인터로 참조할 방법을 만들어두거나...
    // 함수는? 다른 함수에 백업이 되나? -> 아 이건 좀.

    // ...그럼 참조는? 한번 출력을 해볼까?

    std::cout << Print << std::endl; //함수 이름은 쓰되, ()를 뺀다
    std::cout << PrintThese << std::endl; // 즉 실행이 아닌 출력의 대상으로 취급

    // 여기서 우리는 함수의 이름도 포인터, 메모리 주소임을 알 수 있다!

    // 그럼, 메모리 주소가 있으니, 그 주소를 받을 변수도 또 있지 않겠는가????

    // -> 진짜 있다. 그게 바로...

    // "함수 포인터"

    // 함수 포인터는 함수의 메모리 주소를 달아뒀다가, 호출 명령이 나오면
    // 해당 호출된 주소로 가서 그 연산을 실행


    // * 함수 포인터 작성 (기본)

    void (*functionPointer)();

    // void : 이 포인터의 자료형. 이 변수에는 void 함수를 받겠다는 뜻.
    //        만약 int 함수를 받고 싶다면 int 포인터를 만들어야 한다.

    // (* ) : 이 이름에 void 함수 메모리를 할당한다는 뜻. 즉 변수명.
    // 왜 ()를 써서 구분하느냐? : void*하고 안 헷갈리려고.
    //                          포인터의 대상이 함수냐, 변수냐를 구분하기 위함
    // 마지막의 () : 해당 함수가 갖고 있어야 되는 매개변수 구성과 개수
    //              여기서는 그런 매개변수가 없다는 뜻

    // * 함수 포인터 작성 (매개변수가 있는 경우)
    void (*functionPointer2)(int, int);
    // void 반환형에, int 매개변수 둘을 받는 함수를 받겠다는 포인터 변수

    // 함수 포인터는 어떻게 쓰는가?

    // 1. 할당은 변수처럼 한다 = 포인터에 값 넣듯이 한다

    functionPointer = Print;    // 변수처럼 값을 할당하면 끝
                                // Print는 메모리 주소를 받는 거라서 () 안 쓴다

    functionPointer2 = PrintThese;  // 매개변수가 있어도 똑같다
                                    // 이름만 쓰면 된다

    //functionPointer = PrintThese;   // 단, 반환형과 매개변수 구성, 개수는 똑같아야

    // 2. 호출은 함수 호출하듯이 한다 = 함수 포인터를 새로운 이름이라 생각해도 된다

    functionPointer(); // 포인터 이름 + () + ; = 실행
    functionPointer2(100, 33);  // 매개변수가 필요하면 넣어서 실행

    // 이렇게 함수를 다른 이름으로 미리 저장해두면.....

    // -> 1. 함수를 대기시켜 뒀다가 필요할 때 간단하게 호출할 수 있다.
    // -> 2. 만약에 조건에 따라 다른 함수가 필요하더라도
    //       같은 변수에 다른 값을 미리 할당시켜 두면...
    //       똑같은 이름으로 다른 함수를 시작할 수 있다!!!

    // 예시
    functionPointer2 = AddAndPrint; // 아까 쓴 포인터에 다른 함수 등록

    functionPointer2(100, 33); //똑같은 인수로 실행

    // -> 1 + 2. 함수를 만들었지만, 실행의 시점을 100% 개발자가 장악하면서
    //   정확히 무슨 함수를 실행할지도 등록하는 시점에서 개발자가 통제한다?
    // -> 어떤 사건의 후속 결과 등도 개발자가 전부 통제 아래 둘 수 있다!

    // -> 다른 표현으로, 함수를 먼저 만들고, 나중에 실행한다!
    ///   = "이벤트"

    // 예시 : "버튼을 누르면 문이 열립니다." 그런데 누가 버튼을 언제 누를지는 모를 때.
    //       그래도 버튼이 눌린다면, 그 때는 무조건 문이 열리게 만드는 것
    //       그리고 버튼이 안 눌렸는데 문이 멋대로 열리지 않게 만드는 것
    //       -> (다른 수단도 많기는 하지만) 이런 일을 가장 편하고 효율적으로 수행하는
    //          기법이 함수 포인터와 이벤트

    // + 이렇게 이벤트에 대비해서 미리 후속 실행을 준비하고 만든 함수
    //   -> 만들었지만 어디서 실행할지, 언제 실행될지 몰라서 그저 대기 중인 함수
    //   -> 하지만 필요하면 결국 실행되는 함수
    // .....후속 호출 함수, 혹은.... "콜백(callback)" 함수라고 한다.

    // -------------------------------

    // 함수 포인터의 다른 모양 (다른 작성법)

    std::function<void()> fPointerVoid;

    // std::function : 함수 관리 클래스. 단독 사용하면 함수 포인터도 된다
    //                 사실 개발자는 이쪽이 사용 목적의 99%지만....

    // <void()> : 포인터로 받으려는 원본 함수의 반환형과 매개변수

    fPointerVoid = Print; // <- 역시 변수처럼 할당하고...

    fPointerVoid();       // 함수처럼 실행

    // 매개변수가 있는 함수의 경우
    std::function<void(int, int)> fPointerArg;

    fPointerArg = PrintThese;
    fPointerArg(200, 804);

    // functional 기능을 같이 써야 되고 타자 숙지가 힘들지만....
    // 대신 구조가 매우 직관적이므로 (템플릿인데, <> 안에 반환형, 매개변수 다 있음!)
    // 기본 형태가 복잡해 보일 경우, 이쪽을 눈에 익혀두셔도 됩니다.

    // --------------------------------------------------------

    // 다음주 예고 : void*

}

// 헤더에서 만든 함수 정의
void Print()
{
    std::cout << "함수 실행!" << std::endl;
}

void PrintThese(int x, int y)
{
    std::cout << x << " 그리고 " << y << std::endl;
}

void AddAndPrint(int x, int y)
{
    std::cout << x << " + " << y << " = " << x + y << std::endl;
}

void Amugona(int x, int y)
{
    // 뭔진 몰라도 아무거나
}