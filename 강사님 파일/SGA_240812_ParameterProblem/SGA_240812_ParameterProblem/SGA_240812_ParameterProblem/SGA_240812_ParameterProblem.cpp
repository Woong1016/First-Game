#include <iostream>

// c++의 매개변수에 얽힌 문제를 이해하기 위한 샘플 프로젝트입니다.
// 8월 9일과 똑같은 코드고, 해설은 마지막 코드 밑에 추가됩니다.

// 다음 함수를 사용합니다. (8월 9일 샘플 오류 함수)
void ChangeThisFromTo(int from, int to);
// -> 실행하면 from을 to로 바꾸는 함수로 계획

int main()
{

    int first = 100;
    int second = 999999;

    std::cout << "first 숫자 : " << first << std::endl;
    std::cout << "second 숫자 : " << second << std::endl;

    ChangeThisFromTo(first, second); //첫 숫자를 두 번째 숫자로

    std::cout << "함수 실행 결과 first : " << first << std::endl;

}

void ChangeThisFromTo(int from, int to)
{
    std::cout << "---함수를 시작합니다.---" << std::endl;

    std::cout << "from 인수 : " << from << std::endl;
    std::cout << "  to 인수 : " << to   << std::endl;

    std::cout << "<< from을 to로 바꾸기 실행 >>" << std::endl;

    from = to; // 실제 연산 수행

    std::cout << "from 인수 : " << from << std::endl;

    std::cout << "---함수 실행을 마칩니다.---" << std::endl;
}

// 이렇게 함수 내용을 구성하고, 실행하면
// from이 to로 바뀌었어야 하는데, 바뀌지 않았다!! 왜????

// 이 부분을 이해하기 위해서, 우리는 변수의 구성을 다시 알아봐야 한다

// (복습) 변수는 다음 부분으로 이루어져 있다.

// 1. 자료형 : 변수가, 그러니까 이 자료가 어떤 유형의 자료인지
// 2. 변수의 이름 : 이 자료를 어떤 이름으로 지칭해서 컴퓨터에게 이해시킬 건지
// 3. 변수의 진짜 내용

// 다시 말해, 우리가 int a = 0 이렇게 변수를 주면, 컴퓨터는 0이라는 자료를
// 있는 그대로 쓰는 것이 아니고, 'a'라는 이름을 먼저 붙인 뒤에,
// 다시 이 'a'가 있을 만한 컴퓨터(정확히는 메모리) 영역 어딘가를 찾아내서
// 거기에 0이라는 숫자를 넣고, a라고 붙은 이름표를 남겨두는 것.

// 이 사실이 의미하는 것은
// 1. 모든 데이터는 이름과 유형을 지정해줘야 한다..... 가 우리가 먼저 알아낸 것
// 2. 모든 데이터는 이름에 대응하는 컴퓨터(=메모리) 내의 지정 위치도 있다는 것

// -> 다시 말해, 같은 자료형, 같은 실제 내용, 나아가 같은 이름까지 우연히 갖더라도
//    컴퓨터 안에서 반드시 같은 위치에 있다는 보장은 없다!

// -> 그리고 이 "위치가 다를 수도 있다는 것" 이것이 전역변수와 지역변수 사이에
//    이름 중복이 일어나도 괜찮은 이유, 그리고.....
//    같은 계층에서(전역변수끼리, 같은 영역 내의 지역변수끼리)
//    이름 중복이 일어나면 안 되는 이유이기도 하다

// 따라서, 변수 작명 원칙에서 말하는 "이름 같게 짓지 말라"는 말의 "진짜 진짜" 의미
// -> "같은 영역 내에서, 같은 위치에 대고, 다른 선언을 갖는(자료형이 중복되는)
//     그런 변수를 또 만들지 말라"는 의미 ( 이름 중복x, 영역 중복이 진짜 금지)
//     다른 말로 "이름표가 같은 변수를 같은 위치에서 또 만들지 말라"

// 이야기가 길어졌는데... 요약하면 이렇다.

// "컴퓨터는 변수를 그때그때 스스로 정한 메모리의 위치에 이름표로 저장한다."

// 그리고.... 이 사실을 염두에 두고, 다시 다음으로 넘어간다.


// 컴퓨터의 변수 다루는 방식과 더불어서, 이번에는 매개변수를 함수가 다루는 방식을
// 살펴볼 필요가 있다

// -> 먼저, 매개변수는 정확히 무엇인가?
//    답 : 매개변수 역시, 함수에서 미리 지정해둔 지역변수의 일종
//         다만 값이 함수 내에서 정해진 게 아니라, 호출할 때, 호출하는 쪽에서
//         매개변수의 값을 정해줘야 한다는 게 차이점일 뿐.

// -> 그렇다면, "컴퓨터가 변수를 이름표를 붙여서, 일정한 자리에 둔다..."고 했을 때
//    새로운 함수 속에서, 새롭게 만들어진 지역 변수를 또 써야 한다면
//    과연 어떻게 할까?

//    답은 "사실 시대에 따라 다른데... <C 이후 프로그래밍에선 복사로 대응한다>이다"

// 아주 옛날에는 함수에서 매개변수를 주면 컴퓨터는 그 매개변수가 원본을 그대로 쓰게 했다
// (사실 함수의 개념도 희미했다)

//     하지만 지금은 지역변수가 함수마다 엄격하게 나뉘어 있다
//     그렇기 때문에...

//     함수에서 매개변수가 선언되면, 이건 호출 때 들어오는 실제 변수가 무엇이었느냐와는
//     완전히 별개로 변수의 이름표를 따로 떼어 관리한다.

//     다른 말로, "그냥 똑같은 걸 하나 새로 만든다(복사)" 혹은....

//     더 정확한 말로 "미리 똑같은 자료형 변수를 선언해뒀다가 인수의 값을 집어넣는다"

//     ...가 바로 컴퓨터가 C, C++에서 매개변수를 다루는 방식이다.
//     (아래쪽이 좀 더 정확한 표현이지만, 일단은 위쪽으로 이해해도 된다)

// 쉽게 풀어서 위 함수의 예시를 적용하면 이렇다

// 간단히 말하면, main()에서 만들었던 first 숫자와 Change...함수의 from 숫자는
// 사실 같은 100이라는 숫자지만, 실제로는 완전히 다른 변수였던 것.
// (우연히 이름도 다르지만, 이름을 같게 했더라도 완전히 다른 변수로 친다)

// 정확히 말하면, Change...를 실행할 때, first를 대입하면
// 함수는 이 first와 같은 내용을 가지는 from을 다른 곳에 하나 더 만드는 셈

// ...혹은 더 더 더 정확히 말하면, Change...에 있는 from은 처음부터
// first와는 완전히 다른 곳에 있는, 완전히 다른 변수였던 것.
// 단지 호출할 때, from의 내용을 first의 내용으로 지정해준 것뿐.

// 이것도 요약하면 :

// "C, C++ (그리고 이후의 모든 플밍언어 포함) 언어에서 함수 매개변수는
//  호출될 때 집어넣는 변수와는 전혀 다른 곳에서 만들어지는 별도의 지역변수"인 것

// 혹은 위 요약이 이해가 어려운 경우, 우회해서 쉽게 이해하기로

// "함수는 호출하면 매개변수를 다른 곳에 복사한다!"

// 어느 쪽이든 결론은 "함수 호출에 쓰인 first와, 함수 안쪽의 from은 완전 다르다!"
