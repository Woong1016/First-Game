// SGA_241002_MacroFunctions.cpp

#include <iostream>
#include "Amgona.h" // 싱글턴 클래스 하나

// 오늘의 진도 : 전처리기와 매크로(전처리 정의 지시)를 이용한
//              연산 코드의 단순화, 매크로 함수

// 매크로 = 텍스트를 실행 파일 작성 단계에서 다른 글자로 바꿔주는 것

#define MY_MACRO "안녕하세요, 세상이여!"
// 실제 코드에 MY_MACRO를 입력하면, 실행 파일 작성 시 그 텍스트가
// "안녕하세요, 세상이여!"라는 글자로 바뀐다

// 그렇다면.... 이렇게 글자를 바꾸는 것을 통해서
// 연산이나(연산 코드) 함수 호출 등을 만들어볼 수도 있지 않을까?

// 그게 바로 매크로를 이용한 연산 수행, 이름하여 "매크로 함수"

// 매크로를 통해서 사칙연산 만들어보기

#define ADD(x, y) x + y // 이런 작성이 있으면
// 1. ADD라는 매크로를 발견하면, 뒤에 ()가 있는지 보고
// 2. ()가 있으면 그 안에 있는, 쉼표로 구분된 데이터를 각각 x, y인 걸로 친다
// 3. 그 x, y를 포함하는 텍스트를 'x' + 'y'로 바꿔준다
// 4. 결과적으로, x + y의 연산을 실행 파일이 수행하게끔 한다.

// 같은 방법으로 빼기, 곱하기, 나누기도 매크로 함수로 만들기
#define MINUS(x, y) x - y
#define MULT(x, y) x * y
#define DIVIDE(x, y) x / y

// 이 매크로를 main에서 사용하면, 마치 x - y, x * y, x / y인 것처럼 연산 수행

// 텍스트의 변환이란 점을 사용하면 싱글턴 호출 등의 연산도 매크로로 줄일 수 있다

#define AMGONA Amgona::Get()
#define NEXT_NUMBER(n) Amgona::Get()->PlusOne(n)

// --------------------------------------------

// 덤. "텍스트를 보강한 매크로 함수"의 예시

#define MULT_REAL(x, y) (x) * (y)
// 위와 똑같은 텍스트 변환이긴 한데, x, y, 자리에 () 이 글자가 추가되게 해서,
// 연산 수행 시에  x 자리에 오는 데이터가 수식이라도, 혹은 다른 데이터라도,
// 반드시 이 x, y 자리 안에서 개별적으로 먼서 연산을 마친 후에,
// 그 다음 x, y끼리 곱하도록 만드는 매크로 함수

int main()
{
    // 매크로로 바뀐 연산을 직접 써보기

    int a = 10;
    int b = 3;

    // 먼저, 매크로가 없는 보통의 연산
    
    std::cout << a + b << std::endl;
    std::cout << a - b << std::endl;
    std::cout << a * b << std::endl;
    std::cout << a / b << std::endl; // 결과 확인

    // 매크로를 써서 연산을 확인

    std::cout << ADD(a, b) << std::endl; // ADD() 사이 x, y 자리에 a, b 대입
    std::cout << MINUS(a, b) << std::endl;
    std::cout << MULT(a, b) << std::endl;
    std::cout << DIVIDE(a, b) << std::endl; // 결과 확인 : 똑같다 + 문제 없다

    // 즉, 매크로를 통해서 정의된 텍스트를 넣더라도 실제 실행 때는
    // 이미 텍스트가 바뀌어 있기 때문에 똑같은 연산을 수행할 수가 있다!

    // 매크로는 함수의 호출 등에도 쓸 수 있다!

    AMGONA->num = 100; // 싱글턴 사용 시, 타자 수 줄이기

    // 이런 식의 호출을 응용하면 타자 수가 많은 싱글턴 호출 시에 글자를 줄일 수 있다

    // 예 : "무슨 키를 눌렀는가?" = KEY_DOWN 등으로 철자 줄이기...

    // -----------------------------------------------------------

    // 매크로 함수가 그러면 만능인가? 그렇지는 않다.

    // 매크로는 함수의 작성이 아니다. 그저 텍스트를 바꿔줄 뿐이다.

    // 이 사실의 의미는 크게 두 가지.

    // 하나는 "중복이 되면 그만큼 성능을 잡아먹는다" : 했던 연산 또 하고 또 한다

    // 다른 하나는 "텍스트를 바꾸기만 하지, 실제로 연산의 적절성을 보장하지 않는다!"
    // 이쪽이 중요

    // 첫 번째 예시
    // std::cout << DIVIDE(1, 0) << std::endl; // 수행 시에 망하는 코드
                                            // 이걸 막기 위해서 if 등을 적다 보면
                                            // 차라리 그냥 함수는 만드는 게 편하다

    // 두 번째 예시

    // 위에서 만든 a와 b를 곱하면 30이 나와야 한다
    // 그렇다면 a+1과 b+1을 곱하면?? 44가 나와야 맞는다

    // 그런데...
    std::cout << MULT(a + 1, b + 1) << std::endl;
    // 여기서 a+1, b+1을 그냥 텍스트에 대입해서 연산으로 풀어버렸더니
    // 결과적으로 a + 1 * b + 1이라는 식이 된 것. 그랬더니
    // 10 + 1 * 3 + 1 = 14가 되었다.

    // 다행히 두 번째 예시는 텍스트를 좀 더 보강하면 예방을 할 수가 있지만
    // 근본적으로 첫 번째 예시 (인수 자체가 틀린 경우) 그리고
    // 매크로가 좋지 않은 첫 번째 이유 (느리다!) 이것들까지 해결하진 않는다

    // 그러므로 너무 자주는 아니고, 아주 귀찮거나 텍스트가 피치 못하게 길어질 때
    // 적절하게 사용하면 게임 개발의 경우, 작업 효율을 어느 정도 높일 수 있다.

    // * 게임 개발 너머까지 범위를 확장하면 현재로 올수록 비추되는 코딩이기도

    // ------------------------------------------------

    // * 덤. 위에서 이야기한 "텍스트를 보강한 매크로 함수"

    std::cout << MULT_REAL(a + 1, b + 1) << std::endl;
    std::cout << NEXT_NUMBER(999) << std::endl;
}