#pragma once

#include <stdlib.h>
#include <Windows.h>

void ShuffleArray(int target[10]);
void ShowArray(int target[10]);

void ExampleCodeBubbleSort()
{
    srand(GetTickCount64());

    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    ShowArray(arr); // 섞기 전의 배열 출력

    ShuffleArray(arr); // 섞기

    ShowArray(arr); // 섞은 다음의 배열 출력

    // 지금부터 정렬을 시작합니다

    for (int i = 0; i < 10; ++i) // 10개에 대해 10번 비교한다는 뜻
    {
       // for (int j = 0; j < (10 - 1); ++j) // 이쪽이 진짜 비교할 대상
        //{
		//		이 반복문은 중복에 대한 고려가 없다
		//		만야 1차 반복이 끝났으면 이미 맨 오른쪽에 제일 큰 숫자가 있을 테니
		//		반복문에서 빼도 된다
		// 
		//		따라서 j가
		// 
		// 
		// 
        //    // 1. 매 차례 가장 왼쪽에 있는 원소부터 검사해서
        //    // 2. 해당 차례 가장 왼쪽이었던 원소의 '제자리'를 찾아준다
        //    
        //   if (arr[j] > arr[j + 1]) // 0순번이면 1순번과, 1은 2와... 쭉 비교
        //    {
        //        // 조건이 맞으면 자리 바꾸기
        //        int tmp = arr[j];
        //        arr[j] = arr[j + 1];
        //        arr[j + 1] = tmp;
        //    }

        //    // (옵션) 정렬을 할 때마다 중간 결과를 출력해서 확인합니다.
        //    //ShowArray(arr); // * 함수를 미리 만드는 게 이렇게 편합니다.
        //                    // 매번 코드 짤 필요없이 준비해둔 이름만 부르면 끝
        //}

        // 총 10개의 원소에 대해, 오른쪽과의 비교를 끝내고 나면
        // 반드시, 무조건, 어떻게든 정렬은 끝날 수밖에 없습니다.

		// 그리고 여기서 말하는 수학 혹은 정의에 의한 총 계산 횟수 더 나아가
		// 이 알고리즘을 컴퓨터가 실행하면 몇번을 실행 할 것 같은지..

        // 따라서, 거품 정렬의 원칙상 총 계산 횟수는 n(n - 1)입니다.
    }

    //정렬이 끝난 배열 출력
    ShowArray(arr);
	//총 10개의 원소에 대해 오른쪽과의 비교를 끝내고 나면
	// 반드시 무조건 어떻게든 정렬은 끝날 수밖에 없습니다

	// 그러나 거품 정렬의 경우 다른 반복에 의한 계산의 누적... 다시말해
	// 다른 수렴 계산과 마찬가지로 중복이 일어나는 경우의 수가 생깁니다
	//이 수를 연산에서 빼주지 않으면 무의미한 연산이 계속 반복되죠

	// 예 : 이미 제 자리를 잡은 오른쪽의 큰 수들끼리 또 비교하는 것

	// 그래서 아론 연산의 중복을 피하기 위해 반복이 이루어질 때마다
	// 계산의 범위를 1씩 줄여나가줘야 합니다

	// 결과적으로 처음에 10번 마지막에 1번 비교를 하는
	//내림차 계산이 됩니다

	//따라서 거품 정렬의 원칙상 총 계산 횟수는 n(n-1 )이지만
	// 실제 정의 혹은 수학적 총 계산 횟수는 n (n-1) / 2입니다

	// 그리고 여기서 말하는 수학 혹은 정의에 의한 총 계산 횟수 더 나아가 
	// 이 알고리즘을 컴퓨터가 실행하면 최대 몇 번까지 계산할 것 같은지

	// 를 시간 복잡도 라고 부릅니다.


    // 실행이... 잘 될까요? 되겠죠? ㅎㅎ...
}

void ShuffleArray(int target[10])
{
    for (int i = 0; i < 1000; ++i)
    {
        int randA = rand() % 10;
        int randB = rand() % 10;

        int tmp = target[randA];
        target[randA] = target[randB];
        target[randB] = tmp;
    }

    // 배열의 이름은 곧 포인터.
    // 그러므로 이 경우는 매개변수를 직접 바꿔줘도 됩니다.
    // 배열이 아니었다면, 매개변수를 포인터로 선언해주면 됩니다.
}

void ShowArray(int target[10])
{
    for (int i = 0; i < 10; ++i)
    {
        std::cout << target[i];
        if (i < (10 - 1)) std::cout << "  ";
    }
    std::cout << std::endl;
    std::cout << "----------------------" << std::endl;
}