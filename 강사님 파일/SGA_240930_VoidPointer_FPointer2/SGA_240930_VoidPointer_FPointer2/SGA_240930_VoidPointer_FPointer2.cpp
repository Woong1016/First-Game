// SGA_240930_VoidPointer_FPointer2.cpp

#include "Header.h"
#include "SampleClass1.h"
#include "SampleClass2.h"

int main()
{
    // 오늘의 작은 이야기 : 함수 포인터와 포인터의 자료형
    
    // 그리고 포인터를 사용할 때 "자료형 주의!" 하라고 하는 이유

    SampleClass1* sample1 = new SampleClass1();
    SampleClass2* sample2 = new SampleClass2();

    // 0. 전역 헤더(Header.h)에 지금 함수 포인터와 전역 함수가 있는 상태.

    // 전역 함수를 함수 포인터에 넣어보자
    fPtr1 = SampleFunction;
    fPtr2 = SampleFunction;

    //실행해보자
    fPtr1();
    fPtr2();

	//1. 그리고 위에서 만든 샘플 객체 둘을 참고해서, 거기 있는 함수를
	//		전역 변수에 할당해보자 

	//fPtr1 = sample1->Function1;
	//fPtr2 = sample2->Function2;

	//-> 오류가 난다. 왜?? 

	// 이유는 크게 둘. (1) Function 이라는 함수의 소속을 불분명하다고 생각하기 때문
	//				-> 전역변수와 구분하기 힘들다 (옛날) +
	//					인스턴스 참조인지 클래스 참조인지 불분명하다
	//				  (2) 사람이 보면 추상적으로 정확한 판단이 가능하지만
	//					 c++은 정확한 표시가 없으면 의도가 뭔지 판단을 안한다

	// 그래서, 함수 포인터에 다른 클래스 속에 있던 멤버 함수를 할당하려면
	// 해당 클래스와 함수 전체의 위치를 가르쳐줘야 한다 (클래스 함수의 포인터로서)

	// 이렇게 알아두고 할당을 해보면...

	//fPtr1 = &SampleClass1::Function1;	//& + 클래스명 :: 함수명
	//fPtr2 = &SampleClass2::Function2;

	// 이래도 오류가 나는데???

	// void Function1과 void SampleClass1::Function1()은
	// 반환형은 같은데 , 클래스의 위치 ㅡ 데이터 등이 붙으면서 전체 규격이 달라지기 때문

	// 결국 포인터는 원본의 크기를 짐작해가면서 참조범위를 예약하는 것과 같다
	// 그래서 정확한 위치 데이터 규격등을 100% 모르면 저렇게 오류를 낸다

	//2. 여기서 c++의 객체 기능이 유용하게 쓰인다. 

	//std::function<> 기능을 사용하면 함수의 데이터 등을 클래스 사용등에 맞추어서 
	// 유연하게 할당해줄 수 있다.


	// 그리고 기존의 함수 포인터에 적용해서 다른 클래스에 맞추어 쓰도록
	// (참고 : std::function<>도 클래스다. 초록색) 해주는 기능이 추가로 있다.

	//'std::bind' 라는 기능

	//std::function<void()> 형태로 만든 fPtr2에 적용
	//fPtr2 = std::bind(&SampleClass1::Function1); // 역시 안됨

	// 위에서 말했던 참조 위치의 모호성 때문 : 여기까지 해도 모호하다니...

	// 더럽고 치사하지만 , 그렇다.

	// 최종결론: 클래스 멤버 함수를 함수 포인터에 넣으러면 

	//1. 원본함수의  클래스 내 위치
	//2. 참조할 곳 (원본 클래스든 , 만들어진 인스턴스든 !)
	//3. 규격을 조정해서 할당할 수 있게하는 std::function<>

	// 위 세가지를 모두 적용하면 이렇게 된다

	fPtr2 = std::bind(&SampleClass1::Function1, sample1);
				// std::bind : 함수 이름에서 함수 위치, 규격을 추출해서 포인터에 할당하는 기능
	// 이를 '바인딩'이라고 한다.

	// 매개변수 &SampleClass1::Function1 : 함수이름
	// 매개변수 sample1 : 해당 코드를 찾기 위해 시작할 인스턴스의 위치 (이름)

	fPtr2();

	// 그리고 이런 바인딩은 전역 변수만 아니라 다른 클래스의 멤버 변수나 
	// 자기 자신의 함수 포인터에도 똑같이 적용할 수 있다.
	// (샘플 클래스 1,2 에서 확인 -> 특히 2에 std::function<> 사용)

	//샘플 클래스 2에서 할당한 함수 포인터를 호출

	sample2->ptr();


	//-----------------------------------------------

	// 이렇게 함수 포인터에 함수 이름을 넣다보면 새삼 느끼는 것
	// 포인터는 참조 위치가 생명이다

	// 그런데 포인터는 자료형도 생명이다.

	// 또 그런데 포인터는 (예상되는 )데이터 크기도  생명이다
	// 뭐가 조금만 안 맞아도 c++은 특히나 더 컴퓨터가 오류를 내고 까다롭게 군다(새침한 녀석...)

	//더럽고 치사해서 함수 포인터를 안쓰고 싶은데... 
	// "어떤 일이든 연결만 해두면 " 버튼 누르기" 라는 호출명으로 다 시켜주는 UI
	//  내가 만들었지만 실행은 다른 컴퓨터에서 해야 되는 기능(네트워크)
	// 이런걸 우리가 만드는 상황이 오면 함수 포인터는 너무나 쓰고 싶다.

	// 이때 , 사용하는 기능이 두가지

	//1. 컴퓨터가 알아서 자료형을 정해주게 하는 자료형(혹은 정의 지시)

	// "auto" 

	auto fPtr3 = std::bind(&SampleClass1::Function1, sample1);

	fPtr3();

	// auto: 할당식, 사용, 호출 , 자료인 경우 자료가 포함된 큰 분류
	//		(예 : 벡터 속에 있는 원소라든가 )
	//		....들을 보고 컴퓨터가 알아서 자료형을 이거지? 하고 찾아주는 것

	// 장점 : 편하다.

	//단점 : 오류 나기 쉽다.(사용중에 자료형이 갑자기 바뀌거나
	//		오류가 나는 경우, 사용자가 잘 몰라서 그랬을 확률이 높고
	//		따라서 오류가 났는데 왜 났는지도 모를 위험이 조금 높다.

	// 따라서 auto는 진짜진짜 익숙해지고 , 동시에 코딩이 귀찮아지기 전에는
	// 추천할 만한 코딩은 아니다.

	//-------------------------------------------------------------------

	//auto는 대신에 사용가능한, 자유로운 자료형의 사용기능 

	// 그 2번째 : void*, 보이드 포인터


	//-=-----------------------------------------------

	// 보이드 포인터 ? void + *

	// void 이게 뭐였더라? : 자료형에 대한규격이 없다는 뜻
	// 포인터,가 뭐였더라? : 데이터가 있는 메모리 주소

	// 보이드 포인터 : 자료형이 뭔지 모르겠고 , 일단 주소만 받았다는 뜻

	// 한마디로 문자 그대로 "아무거나"

	void* a;//보이드 포인터

	// 일반적인 변수들

	int n = 10;
	float f = 2.2;
	char l = 'a';

	// 위 변수의 무엇이든 보이드 포인터에 할당이 가능

	a = &n; //가능
	a = &f;	// 가능
	a = &l;	// 완전가능

	//심지어 함수도 된다

	a = SampleFunction; // 된다

	// 참고 : 보이드 "변수"는 없다 . 불가능

	// 규격이 없으니 데이터를 담을 수도 없다.


	// 이런 보이드 포인터는 왜 쓰냐? 편하니까

	//1. 자료형이 정확히 뭔지 몰라서 대응하기 힘들때, auto처럼 만능으로 쓸 수 있다.
	// 
	//2. 위에서 봤듯 ... 뭐든지 붙이면 붙는다. 심지어 자료형 교체도 된다.

	//-------------------------------------------

	// 그런데 왜 보이드 포인터를 이렇게 늦게 알아보느냐? 자주 안쓰니까

	// 왜 자주 안쓰는가? 불편하니까. (방금은 편하다더니)

	// 데이터를 할당하고 있을 때는 편하다. 

	// 대신 void*의 불편은 호출에서 나온다.

	// 무슨 말인가? 데이터에 현재 주소만 있고 규격이 전혀 없으니까 
	//				컴퓨터가 주소를 봐도 어떻게 해석할지를 모르는 상태라는 것
	//		따라서 보이드 포인터는 호출할 때 , 호출하는 코드에서항상! 무조건! 반드시!
	// 자료형 지정을 다시 해줘야 한다.

	a = &n; // 정수로 할당을 했다면...

	//(int)a; // 호출할 때도 정수로 분명하게 형 변환을 해서 호출을 해야한다. 
			// 그리고 이렇게 자료형만 써도 안되고 ,., (왜냐하면 이건 포인터니까)

	*(int*)a; // 보이드 포인터를 => 정수의 포인터로 바꿔준 후,
				// 다시 그 주소값을 역참조 해서 (*)값을 호출해야 한다.
	std::cout << *(int*)a << std::endl;

	a = &f; // 소수라면


	std::cout << *(float*)a << std::endl; // 호출도 소수로 형변환

	a = &l;// 글자라면?

	std::cout << *(char*)a << std::endl;
	
	a = SampleFunction; // 함수 포인터로 만들었으면 호출할 때도 함수 형식을 다 써줘야 한다.
						// 그리고 보통은 이 정도로 복잡하면 그냥  함수 포인터나 매크로 쓴다.
	

	//요약하면 : void* 는 무엇이든 담을 수 있는 만능 포인터이기도 하지만

	// 진짜 본체는 호출하는 쪽이 모든 귀찮음 , 오류 위험등을 전담하는
	
	// "착불 포인터" 따라서 데이터를 설계할 때 어떤 데이터일지
	//	예상하기 힘들거나 , 종류가 많아서 호출 부담을 감수를 해서라도

	// 적은 변수로 자유로운 코딩을 해야하는 경우가 생길 때 쓰면
	//최고로 유연한 코딩이 가능하다.

	//짝짝짝짝짝


	//---------------------------




	// 보이드 포인터는 객체에도 쓸 수 있다.

	// 당연한 소리지만 확인하는 것에 의미

	// *위에서 만든 두 샘플 인스턴스를 보이드 포인터로 불러오기

	void* i = sample1;// 클래스 1의 인스턴스
					// 인스턴스가 이미 포인터로 만들어져 있어서
					// &는 생략해도 된다



	// 부를 떄 i밖에 괄호를 한번 더 쳐서 i룰 먼저 형변환을 하고
	// 그 다음에 -> 로 접근한다고 지정해줘야 한다.
	((SampleClass1*)i)->Function1();	// ((SampleClass1*)i) 모양 주목

	// 이어서 대상을 클래스 2로 교체후 다시 다른 함수 호출


	i = sample2;

	((SampleClass2*)i)->Function1();
	// 클래스 2번 사용

	//보이드 포인터는 포인터로 변환, 연산 가능한 모든 데이터에 적용가능

	// 보이드 포인터의 약점, 혹은 한계: '포인터로 못 바꾸는 것들'은 연산 못함

	// 예: 일부 시스템 함수로 구분되는 기능들, 일부 템플릿 
	// 그리고 .... std::function<> 이 기능도 보이드 포인터하고 호환안됨...
	// 단 이경우 , 객체가 void* 취급이 가능하므로 객체를 void*로 쓰면 ok

	//^=^
}

