#include <iostream>

#include "Readout.h" // 참고용 메모 파일

#include "Human.h"   // 인간 클래스 (부모 클래스)
#include "Citizen.h" // 시민 클래스 (자식 클래스)
#include "Student.h" // 학생 클래스 (자식의 자식)
#include "Worker.h"  // 노동자 클래스 (또 다른 자식)

#include "homework.h" // 과제 설명은 여기서

int main()
{
    // 배경 이야기 : "메모 파일에서 진행 중에 이야기를 나눠보겠습니다."
    //              "나중에 복습할 때도 메모 파일을 먼저 읽어주세요"

    // ------------------------------------------------------------

    // 클래스로 표현 가능한 객체는 하나의 개념만이 아니라
    // 소속의 관계를 가진 복잡한 계층으로 표현 가능하기도 하다

    // 실질적인 예 : "학생 A"
    // 이 A는 학생이면서, 동시에 시민이면서, 동시에 인간이기도 하다

    // 그렇다면 이 A는...
    // 인간으로서 -> 밥 먹는 기능을 갖고 있을 것.
    // 인간으로서 -> 움직이는 기능도 갖고 있을 것.
    // 또한 시민으로서 -> 지하철 탈 능력도 갖고 있을 것.
    // 또한 시민으로서 -> 투표를 할 자격도 갖고 있을 것.
    // 그리고 학생으로서 -> 공부를 할 능력과...
    // 그리고 학생으로서 -> 과제를 할 능력도 갖고 있을 것.

    // 이렇게 인간의 특성, 시민의 특성, 학생의 특성을 모두 갖고 있는
    // 이런 "학생"을 c++에서는 어떻게 구현할 것인가?

    // -> 실제 코딩 전에 잠깐 계층 순서부터 정해두자

    // 위에서 A는 학생이면서 시민이면서 인간이다....라고 했는데
    // 생각해보면 이 안에서 명백한 소속의 순서가 정해져 있다.

    // 모든 학생은 (문명사회에서) 지하철 탈 줄 알고 투표할 자격이 있다
    // 또한 모든 시민은 밥 먹고 움직일 줄 알 것이다

    // = 학생이라는 말 자체가 시민을 전제한 것. 시민은 곧 인간의 일부분.
    // 다른 말로 "인간 안에 시민이, 시민의 한 부분에 학생이라는 정체성이" 존재.

    // 이렇게 표현 가능한 대상의 소속의 계층 순서를 따라
    // 클래스를 코드로 구현해보고자 한다.

    // -> 이렇게 소속의 관계를 코드로 구현하는 행동을 [상속]이라고 한다.
    //                                             (inheritance)

    //-----------------------------------------------------------------

    // 인간 객체 만들기

    Human* human = new Human(); // 생성자를 안 만들었는데, 괜찮은가?
                                // -> 괜찮다. 왜냐면 모든 클래스는
                                // 자동으로 숨겨진 기본 생성자가 있어서

    human->age = 100; // 나이 할당 (=변수를 쓸 수 있다는 확인)
    human->Eat();     // 먹기 행동 (=함수를 쓸 수 있다는 확인)

    // 키 할당, 씻기 행동은 불가능 (private이니까)

    // ----------------------------------------------------------------

    // 시민 객체 만들기

    Citizen* citizen = new Citizen();


    // 시민에게 가능한 행동
    citizen->birthday = 840101; // 생년월일 할당
    citizen->Subway();          // 지하철 타기

    // -> 모든 시민은 (지금은) 곧 인간이므로, 인간의 행동도 가능...?
    citizen->age = 300;         // 부모 클래스 변수 호출 가능
    citizen->Eat();             // 부모 클래스 행동도 사용 가능

    // human->Workout(); // 보호 데이터 부모 클래스에서 사용 불가
    // citizen->Workout(); // 보호 데이터 자식 클래스에서 사용 불가

    citizen->WorkoutAsHuman();  // 자식 클래스의 public 함수로
                                // 보호 데이터 간접사용

    // --------------------------------------------------

    Student* student = new Student();

    // 변수 호출 가능 확인
    student->inCourse = true; // 본인 데이터 사용
    student->birthday = 19880101; // 부모 데이터도 사용
    student->age = 10;     // 부모의 부모 데이터도 (public이라면) 모두 사용

    // 함수 호출
    student->GoAcademy(); // 자기 함수
    student->Subway();    // 부모 함수
    student->Eat();       // 부모의 부모 함수

    student->WorkoutAsHuman(); // 부모의 보호된 데이터 사용
    student->GoDoctorAsCitizen(); // public 함수로 부모의 보호 데이터 간접사용

    // 이렇게 자식 클래스를 써보는 것으로 확인 가능한 것:

    // 자식 클래스를 만들고, 부모 클래스를 public으로 상속하고
    // protected와 public을 잘 써주면...

    // 부모 클래스의 기능을 이어받으면서도, 다시 자신만의 추가 데이터를 쓸 수 있는
    // 별도의 클래스를 파생해서 만들 수 있게 된다!

    // ------------------------------------------------------------

    // 클래스 상속에 대한 추가 응용

    // 1. 상속의 분화 (나뉘기)

    Worker* worker = new Worker();  // 또 다른 시민의 자식 객체

    worker->Work(); // 시민 함수 호출 가능. 데이터 마찬가지
    worker->Eat();  // 부모는 물론 부모의 부모 함수도 다 호출 가능

    // worker->Academy(); // 이거 안됨
    // student->Work();   // 이거도 안됨

    // 확인하자면, 노동자와 학생은 모두 시민의 자식 클래스라 시민의 행동은 가능
    // -> 서로 간에 직접 소속 관계는 없기에 시민이 학생 행동은 불가능
    //    마찬가지로 학생이 시민 행동도 불가능.

    // 따라서 같은 부모를 뒀어도 서로 직접 포함관계가 없다면
    // 반 정도는 남인 것처럼 이해를 해야 한다 (비유하자면 '형제')
    // -> 이것이 상속의 분화

    // ---------------------------------------

    // 2. 자식 클래스의 부모 함수 갱신(혹은 덮어쓰기, override)

    // -> 노동자 클래스에서 확인 후 사용

    student->GoDoctorAsCitizen(); // 학생 안에 있는, 시민의 "병원 가기" 실행
    worker->GoDoctor(); // 노동자에게 public으로 고쳐진, 같은 철자 함수 실행

    // 위 함수는 따지고 보면 똑같은 GoDoctor() 함수를 실행한 것

    // 그러나 자식 클래스에서, 같은 철자(정확하게는 같은 "함수로서의 이름" 즉
    // "같은 함수 이름, 같은 자료형, 같은 매개변수 종류, 같은 매개변수 개수")
    // ...를 갖춘 함수를 또 작성하면....

    // 1) 자식 클래스의 함수는 부모 클래스의 것에 우선하게 된다
    //    다른 말로 부모 클래스의 함수가 무시된다 (="덮어씌인다")

    // 2) 덮어씌이는 과정에서 접근지정자 역시 자식 클래스의 것으로 갱신된다.

    // 이렇게 자식 클래스에서 부모 클래스의 함수를 덮어쓰고 고쳐 쓰는 것을
    // 함수의 오버라이드라고 한다 (오버로드와 덜 헷갈리려고 원문 발음이 흔하다)

    // 확인 및 복습

    worker->Drive(); // 시민 클래스에 있던 Drive 함수를 노동자 클래스에서
                     // 오버라이드한 것
}