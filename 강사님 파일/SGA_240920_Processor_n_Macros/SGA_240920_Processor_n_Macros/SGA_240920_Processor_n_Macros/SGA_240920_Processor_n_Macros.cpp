 // SGA_240920_Processor_n_Macros.cpp

// 과제 : 오늘부터 9월 30일까지.

// 당일 과제는 나오지 않습니다. 대신 자유 게임 개발에 도전해주세요.

// 자유 게임 개발 : 현재까지 배운 코드를 활용해서, 그리고 아이디어를 동원해서,

// 현재 기준 C++ 콘솔에서 실행할 수 있는 재미있는 게임을 만들어봅시다.

// 예시 : 텍스트로 돌아가는 추리 게임, 과제로도 했던 카드 게임, 빙고 완전판,
//        테트리스, 그리고....의외로 가능한 장르인 실시간 액션
//        힌트 : 'sleep'이라는 C++ 코드가 있습니다.

// * 과제에서 추가로 가능한 것 : 권장 사항은 아니지만,
//   게임 개발에 필요하다고 생각하시면 C++, 콘솔에 사용되는 다른 코드를 쓰셔도 됩니다.
//   (인터넷 자습 등으로 알아본 함수)

#include <iostream>
#include "Processor.h"

// 오늘의 진도 : 지시(process)와 전처리(processor) 과정을 좀 더 알아보는 것
 
int main()
{
    // 지시 : 코드 수행 중에 연산과 같이 할 작업을 정의, 지시하는 것.

    // 지시의 예 : typedef (데이터, 연산 명명 혹은 이미 정의된 데이터를 재명명)
    typedef int SUTZA; // int라는 자료형에 '숫자'란 이름을 덧씌운 것

    // 이전에 살펴본 지시 : typedef('자료형 재정의') template('논리구조')

    // 다른 지시

    // 1. 자료형의 이름 : 이것도 사실 지시다.
    //                   지시를 함으로써 데이터가 무엇으로 분류되는지 지목

    // 2. 코드의 영역(struct, class, namespace) : 이 영역의 코드가
    //                                           어떻게 작업되는지 지목

    // 3. using : 네임스페이스를 지금 사용하고 있다는 지시
    //            따라서 '사용 중인 네임스페이스의 이름'은 생략 가능

    // 4. (현재 권장 안 함) auto : 템플릿처럼 자료형을 미리 지정하지 않는단 뜻
    //                            컴퓨터한테 자료형 판단을 위임한다.
    //                            (=앱이 알아서 자료형이 뭔지 멋대로 판단한다)

    auto a = 10.5f; // <- 실행했을 때, 아마, 앱이 소수인 걸로 치지 않을까...?
    char word[9] = "computer"; // 문자열
    auto let = word[3]; // <- 실행했을 때, 아마, 앱이 글자나, 정수로 치지 않을까
    std::cout << let << std::endl; // 출력하면 앱은 글자를 출력
                                   // = "문자 배열 중 하나니까 글자겠거니"

    // 자동으로 자료형을 찾아주기 때문에 복잡한 코드를 쓸 때,
    // 개발자가 자기 코드를 100% 정확하게 이해도 하고 있다면 좋은 지시가 되지만...
    // 그렇지 않다면 의도와 다른 데이터가 나올 위험도 있어서, auto는
    // 완전히 자기가 c++, 혹은 자기가 쓰는 환경을 익숙하게 여기기 전에는 비추

    // -----------------------------------------------------------------

    // *팁 : 비주얼 스튜디오, 기본 색 테마, C++ 언어일 때 지시 쉽게 확인하는 법
    //       파란색이면 지시이다.

    // -----------------------------------------------------------------

    // 전처리기 (processor) : 지시 중, 앞에 # 연산자를 붙여서
    //                       별도 과정에서 작업하게 만든 것

    // 구체적으로는 파일이 실행되기 전, 혹은 실행 파일이 만들어지기 전
    // (이 작업을 컴파일이라고 한다) 미리 # 지시어부터 맨 먼저 수행부터 하고 본다
    
    // * 번역이 원문과 전혀 다른 이유 (맨 먼저 처리한다고 "전" 처리기라고 부른다)

    // -> 전처리기에 대한 추가 소개는 별도 헤더에서 진행
    //    -> Processor.h
    

    // --------------------------------------------
    // 헤더에서 만든 전처리기 (매크로, 조건문) 테스트

    // * 이 부분은, 여기만큼은 익숙해지는 편이 좋습니다! (복습 추천)

    int arr[ARRAY_SIZE]; // 매크로를 사용한 배열 선언
                         // [] 안에 우리는 ARRAY_SIZE라는 단어를 넣었지만
                         // 컴파일을 하면 저 자리에는 10이라는 숫자가 들어간다

    for (int i = 0; i < ARRAY_SIZE; ++i) // 여기서도 매크로가 10으로 바뀔 것
    {
        arr[i] = i; // 숫자를 할당해주고...
        std::cout << arr[i] << std::endl; // 곧바로 출력까지
    }

    // 여기서 매크로가 쓰이면 좋은 점
    // 1. [] 안에 숫자가 아닌 이해할 수 있는 단어를 넣어줄 수 있게 된다
    //    (그냥 변수는 이게 되던가.....?)

    //int size = 10;
    //int newArr[size]; // 원래 이 자리는 상수만 올 수 있다 = 변수 불가능

    // 하지만 매크로를 [] 안에다 쓰면 -> 매크로는 변수가 아니므로 괜찮다
    // (매크로는 그저 텍스트 변환일 뿐. 컴파일하면 10이라는 숫자로 바뀌니까)

    // 2. 나중에 코드 수정 중에 배열의 크기를 바꿔야 한다면???
    //    -> 매크로를 썼다면 그 매크로가 있는 곳으로 가서 숫자만 바꿔주면 된다
    //       (안 썼으면 배열 선언에도, 반복문에도 모두 숫자를 바꿨어야 하지만.)

    // 물론 어디까지나 텍스트를 바꾸는 것뿐이기 때문에 만능은 아니지만
    // 매크로 역시 다른 코드처럼, 잘 쓰면 편하다.

    //------------------------------------------------------

    // 매크로의 다른 사례

    SUTJA number = 80000; // int 같은 자료형 이름이 아닌 매크로를 썼지만...
                         // 컴파일을 하면 매크로에 의해 SUTJA란 단어가
                         // int로 바뀐다. 그러므로 실은 int number와 같다

    std::cout << number << std::endl; // 그 사실을 출력으로 확인
    std::cout << (short)number << std::endl; // SUTJA의 단어가 int임을 확인
                                             // int가 맞다면, short 자료형으로 바뀌면서
                                             // 버려지는 데이터가 나오고, 숫자가 작아질 것.

    // short : 먼 과거에 int 자료형이었던 '작은 정수'를 담기 위한 자료형
    //         차지하는 메모리가 int의 절반(2바이트) 따라서 최대 65535까지 지정 가능
    //         혹은 (65536 / 2 * -1)부터 (65536 / 2 * 1)까지 지정 가능

    // -> 이렇게, 매크로를 사용하면 코드로 작성해야 할 숫자, 혹은 명령어, 혹은
    //    다른 연산이라도 지정을 해서 편하고 친숙한 단어로 바꾸어 두었다가
    //    일괄 호출, 일괄 수정 등에 활용할 수 있게 된다.


    // 매크로의 텍스트 변환 기능 확인

    const char* sayHello = TEST_STRING; // 컴파일 시에 큰따옴표까지 포함해서,
                                        // 모두 변환을 시켜줄 것이다

    std::cout << sayHello << std::endl;

    //const char* notWord = IAMHERE; // 변환할 텍스트가 없고, 있다쳐도 연산자도 없어서
                                     // 맞는 데이터로 취급되지 못한다

    // -> 하지만 IAMHERE라는 매크로가 존재는 한다. 그게 중요

    // --------------------------------------------------------

    // 전처리 조건문 써보기

    // 일반 조건문
    if (CONDITION_A > 0)
        std::cout << "일반 조건문 실행" << std::endl; // 한줄 조건문 = {} 생략가능

    // 전처리 조건문을 사용하면...

#if CONDITION_B > 0     // 전처리기는 줄 단위로 코드를 읽는다.
                        // 별도의 코드 범위를 지정할 수가 없다
    std::cout << "매크로, 전처리 조건문 실행" << std::endl;
#endif                  // 그래서 조건문이 끝날 때, 끝났다고 해줘야 한다
                        // #endif가 그 명령어

#if CONDITION_A > 10000
    std::cout << "전처리 다중 조건문 결과 1번" << std::endl; // 어둠처리
#elif CONDITION_A > 1000 // else if와 같은 뜻
    std::cout << "전처리 다중 조건문 결과 2번" << std::endl; // 어둠처리
#else                    // 그냥 else
    std::cout << "전처리 다중 조건문 결과 3번" << std::endl; // 밝게 활성
#endif
    // -> 전처리 매크로 조건문을 작성할 경우, 조건에 해당이 안 될 것 같은 코드는
    //    비주얼 스튜디오 작업 시, 텍스트가 어둡게 나온다. 그리고 실행파일 빌드 시엔
    //    그냥 텍스트가 사라진다 (어차피 작업도 안 할 것)

    // 전처리 조건문은 변수를 감지할 수 있을까?

    int condition = 10;
#if condition > 0
    std::cout << "일반변수 + 전처리 조건문" << std::endl;
#endif

    // -> 전처리 조건문도 변수가 "있음"은 감지할 수 있다. 하지만...
    // 해당 변수에 어떤 데이터가 있는지는 알 수 없다. 왜????
    // condition에 10이라는 숫자를 넣기도 전에, 이미 전처리기를 먼저 돌리니까.
    // -> 사실상 감지할 수 없는 것이나 다름없다.

    // -> 따라서 전처리 조건문도 완전 만능은 아니고, 매크로와 같이 사용했을 때
    //    가장 적절하게 쓸 수 있다.

    // -----------------------------------------------------

    // 매크로 조건문은 그러면 매크로 비교에만 쓰는가?

    // -> 한 가지 사용처가 더 있다. 바로.... "매크로로 선언된 특정 키워드 감지"

    // 다른 말로 "특정 단어가 매크로로 선언된 적이 있는가?" 여부에 따라
    // 조건문 실행 가능.

#ifdef IAMHERE           //  #ifdef : "해당 매크로가 존재하는지"만 보는 조건문
                         // 아까 우리가 적은 '데이터 없는 매크로' 사용해보기

    std::cout << "나는 여기에 있다" << std::endl;
#endif

    // #define 뒤에 따라오는 데이터 없는 매크로와 같이 사용했을 때,
    // 사용자(프로그래머)는 자기 프로젝트에 키워드를 부여하고
    // 해당 키워드가 있을 때만 동작하는 코드를 이렇게 준비할 수 있다.

    // -> 그래서 이런 매크로 선언을 활용한 조건문에 자주 사용되는 키워드가
    //    DEBUG 라는 매크로다. (자동완성 키워드)

#ifdef DEBUG // 왼쪽의 DEBUG가 매크로로 선언됐으면 아래 코드가 수행
    // 여기서 디버그 전용 코드 작성
#endif

    // 이렇게 전처리기 조건문 활용 가능.

    //--------------------------------------------------------------

    // 조건문에 else가 있듯이, 조건 지정에 != 연산자가 있듯이,
    // 키워드에도 매크로 선언 감지와 같이 쓸 수 있는

    // "해당 매크로가 선언된 적이 없으면 수행되는" 조건문이 존재
    // #ifndef

// #define YOUAREHERE // 이걸 선언하면 아래 코드가 실행 안 됨

#ifndef YOUAREHERE // You Are Here가 없으면 수행되는 조건문
    std::cout << "너는 여기엔 없다" << std::endl;
#endif // !YOUAREHERE

    // ------------------------------------------------------
    // 마지막으로 매크로로 어떤 키워드를 선언했는데, 취소한다면?
    // -> #undef

#undef IAMHERE // 아까 작성한 매크로 취소

#ifdef IAMHERE // 매크로가 헤더에 작성됐지만, 지금 취소됐으므로...
    std::cout << "안녕히 계세요, 여러분!" << std::endl; // 이 코드는 무조건 패스
#endif

    // --------------------------------------------------

    // 여기까지 코드 작성으로 알 수 있는 것
    
    // 1. 전처리기가 실행이 된다는 것

    // 2. 전처리기 실행 시점은 코드 수행보다 더 일찍이라는 것 (중요!!)
    //    -> 조건문이 안 맞으면 텍스트가 까매짐 (사라짐)
    //    -> 변수의 값을 읽지 못함 (할당하기 이전에 전처리기 실행)

    // 3. 매크로와 조건문 작성 방법과 활용
}